<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nekonull&#39;s Garden</title>
    <link>https://nekonull.me/</link>
    <description>Recent content on Nekonull&#39;s Garden</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>CC-BY-SA-4.0</copyright>
    <lastBuildDate>Tue, 01 Apr 2025 14:55:44 +0000</lastBuildDate><atom:link href="https://nekonull.me/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Today I Learned - 更简单更频繁的分享</title>
      <link>https://nekonull.me/share/til-for-simpler-sharing/</link>
      <pubDate>Sun, 30 Mar 2025 21:00:34 +0800</pubDate>
      
      <guid>https://nekonull.me/share/til-for-simpler-sharing/</guid>
      <description>&lt;p&gt;对我来说，写文章其实是心理门槛挺高的一件事，会觉得得对某个事物充分了解，完全掌握了，才有动力去下笔。（虽然大概这里的文章并没有达到这样一个状态。）但也有时候，我见到了一个有趣或者有用的事物，可能是一篇论文、一个项目、一条视频，或者只是简单的一个想法，会有分享的欲望。为此写文章有些太大动干戈了，但是不将他们分享出去又有些可惜。现实生活里我有一个小群来分享这些东西，但我认为它们值得被更多人看到。&lt;/p&gt;
&lt;p&gt;因此，在我经常阅读的另外两位创作者 &lt;a href=&#34;https://til.simonwillison.net/&#34;&gt;Simon Willision&lt;/a&gt; 和 &lt;a href=&#34;https://jvns.ca/til/&#34;&gt;Julia Evans&lt;/a&gt; 的启发下，去年年底我创建了一个名为 TIL (Today I Learned) 的分类。形态上类似于微博或者 Reddit，基本上都是一个链接 + 一些简短的介绍，意图在于让读者快速了解这些事物是否对 ta 们有帮助，并将流量引导到原作者。&lt;/p&gt;
&lt;p&gt;但创建这个分类之后，我发现自己的分享频率并没有显著上升。后来我意识到，虽然有了单独的分类，但是发布行为本身并没有简化。即使我只是想快速分享一个链接，我依然要采用和正式文章完全相同的方式：在编辑器里新建一个 Markdown 文件，写 front matter 和文章正文，预览，推送到 Github 仓库。如果这个新分类的定位类似于微博，那为什么不能像真的发微博那样简单呢？&lt;/p&gt;
&lt;p&gt;这个月初，我调整了下 TIL 的发布方式，做法类似于 headless CMS。具体而言，在某个地址有一个简单的页面，里面有一些基本字段（标题、URL）和一个 Markdown 编辑器，还有一个“发布”按钮。在我填充完基本信息，点击“发布”之后，会触发一个云函数，读取请求，调用 Github API 完成 Repo 内新文件的写入。虽然技术上来看这并不复杂，但却极大减少了发布的心理负担。现在当我想分享的时候，只要打开这个页面，快速把内心的感受 dump 进去，点击发布，就算完成了。&lt;/p&gt;
&lt;p&gt;当然，考虑到 TIL 形式的分享贴所含的信息量更低，不能排除正常读者会被打扰的可能性。为此，我修改了 Hugo 的 RSS 模板，将 TIL 和正常文章拆分成了两个 RSS 源。TIL 的分享只会在单独的 TIL 订阅源中出现，以确保读者只有在明确想收到这些分享的时候才会收到。（这也是从 Simon Willison 那里学到的，他有一个名为 &lt;code&gt;atom-everything&lt;/code&gt;  的订阅入口。）&lt;/p&gt;
&lt;p&gt;最后是一些相关链接。希望你也能发现我的 TIL 对你有帮助。感谢阅读！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TIL 入口：&lt;a href=&#34;https://nekonull.me/til/&#34;&gt;https://nekonull.me/til/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RSS：&lt;a href=&#34;https://nekonull.me/til.xml&#34;&gt;https://nekonull.me/til.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>code2prompt - 满足「这是怎么做到的」好奇心的小工具</title>
      <link>https://nekonull.me/share/code2prompt/</link>
      <pubDate>Sun, 30 Mar 2025 15:57:05 +0800</pubDate>
      
      <guid>https://nekonull.me/share/code2prompt/</guid>
      <description>&lt;p&gt;我发现自己经常对着一个有趣的 Github Repo 思考：「这看起来真不错！但是究竟是怎么做到的？」。但很多时候我无法满足我的好奇心。要么是这个项目并没有自带一个「How it works / 工作原理」的介绍（在我看来这应该是每个项目 README 的必备），要么是我没有时间或者耐心在层层叠叠的文件树或者错综复杂的调用链里自己找到答案。得益于近来 LLM 的上下文窗口增长，让 LLM 来帮我回答这一问题似乎是个不错的选择。即使 LLM 回答给出的答案可能有错误或者不完整，但至少能给出一些探索方向，让我自己的理解更有效率。然而在通常的对话窗口里复制粘贴代码有些烦人，更别提无法在文件数多的项目里应用了。为此，我（让 LLM）帮我写了一个小工具，让我能更方便的从代码生成发送给 LLM 的 prompt。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;体验地址：&lt;a href=&#34;https://nekonull.me/code2prompt/&#34;&gt;https://nekonull.me/code2prompt/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;代码库：&lt;a href=&#34;https://github.com/jerrylususu/code2prompt&#34;&gt;https://github.com/jerrylususu/code2prompt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何使用&#34;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;具体使用起来很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在GitHub项目页面，点击右上角&amp;quot;Code&amp;quot;→&amp;ldquo;Download Zip&amp;quot;下载代码&lt;/li&gt;
&lt;li&gt;打开工具页面，点击&amp;quot;选择文件&amp;quot;并上传刚下载的zip包&lt;/li&gt;
&lt;li&gt;根据文件数量或token大小进行筛选（比如排除test/、vendor/或package-lock.json等无关文件）&lt;/li&gt;
&lt;li&gt;点击&amp;quot;Generate&amp;quot;生成提示词&lt;/li&gt;
&lt;li&gt;点击&amp;quot;Copy&amp;quot;复制到剪贴板，然后粘贴到你喜欢的LLM对话工具中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有一些其他特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件树可以一次选中/取消选中整个文件夹&lt;/li&gt;
&lt;li&gt;每个文件旁标记了该文件的大小和 token 预估&lt;/li&gt;
&lt;li&gt;点击文件，可以直接展示该文件的内容（monaco editor）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现原理&#34;&gt;实现原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;解析zip文件（jszip 库）&lt;/li&gt;
&lt;li&gt;计算每个文件的token占用（用的是 gpt-tokenizer，基于 cl100k 计算，也就是 gpt-3.5-turbo 的分词器）&lt;/li&gt;
&lt;li&gt;展示文件列表和占用空间最大的文件，并根据选择更新&lt;/li&gt;
&lt;li&gt;最后用文件内容填充预设的提示模板&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用技巧&#34;&gt;使用技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模型：用上下文足够长的模型，注意上下文限制；如果有可能的话用带上下文缓存的提供商
&lt;ul&gt;
&lt;li&gt;比较推荐的模型
&lt;ul&gt;
&lt;li&gt;Gemini 2.0 Flash Lite：输入 ￥0.55/1m, 输出 ￥2.19/1m, 上下文 1m&lt;/li&gt;
&lt;li&gt;qwen-turbo：输入 ￥0.3/1m, 输出 ￥0.6/1m out, 上下文 1m&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果最后得到的 token 数少，再考虑 deepseek-v3（官方上下文 64k，部分提供商 128k）等模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;筛选：根据自己的需要提前删掉不需要的文件
&lt;ul&gt;
&lt;li&gt;二进制文件已经预先被筛掉了，不会出现在文件树里&lt;/li&gt;
&lt;li&gt;test / vendor / docker 相关的通常可以做排除&lt;/li&gt;
&lt;li&gt;如果只看后端，则可以把前端的全排除掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提示词：建议加在输入的最后，避免模型丢失焦点
&lt;ul&gt;
&lt;li&gt;首次阅读：简要说明代码做了什么， 以及是如何做到的。列出核心函数所在的位置。&lt;/li&gt;
&lt;li&gt;理解流程：用 mermaid sequence diagram 说明 XXX 的完整流程&lt;/li&gt;
&lt;li&gt;分析结构：这个项目主要有哪些组成部分？用 mermaid flowchart 展示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开发&#34;&gt;开发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大部分都是 LLM 写的（Windsurf + Claude），人主要是测试和提出修改意见。&lt;/li&gt;
&lt;li&gt;目前并没有用任何前端框架，都是裸 DOM 操作。（主要原因是没找到一个比较好的不需要构建过程的前端框架使用方式）。&lt;/li&gt;
&lt;li&gt;一开始的时候只是一个简单的单页面（所有代码都在 index.html）里的小应用，但随着复杂度上升和功能增加不得不做重构，拆分多个文件（不然的话编辑操作会因为影响行数过多常常失败）。未来可能一开始就考虑多文件架构会比较合适。&lt;/li&gt;
&lt;li&gt;目前每次 LLM 改完之后，得靠人手动操作下来验证是否有功能被破坏，有点麻烦。要是能有更自动化的 E2E 测试（例如基于 Playwright）就好了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可能的后续方向&#34;&gt;可能的后续方向&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;直接从 Github 加载：目前直连 Github 下载 zip 会有 CORS 问题，需要一个后端来代理下（但是就引入额外的运行成本了；我还是更喜欢纯前端而不依赖任何后端的工具）&lt;/li&gt;
&lt;li&gt;预设提示词：提供几个常用提示模板方便一键使用&lt;/li&gt;
&lt;li&gt;本地文件夹支持：直接加载本地项目文件夹&lt;/li&gt;
&lt;li&gt;gitignore支持：自动忽略.gitignore中指定的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他方案对比&#34;&gt;其他方案对比&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cursor / Windsurf：需要依赖编辑器自己去读取文件，慢而且可能会缺失文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yamadashy/repomix&#34;&gt;repofix&lt;/a&gt;：开发之后才关注到，前端缺少控制能力，用起来不太方便&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/simonw/files-to-prompt&#34;&gt;files-to-prompt&lt;/a&gt;：纯命令行工具，对我这种临时性探索稍微有点繁琐（但是用在其他工作流里可能比较合适）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The drive to develop</title>
      <link>https://nekonull.me/posts/the-drive-to-develop/</link>
      <pubDate>Mon, 03 Mar 2025 23:23:31 +0800</pubDate>
      
      <guid>https://nekonull.me/posts/the-drive-to-develop/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这是一期杂谈，没什么干货。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;“The drive to develop” 是早年间喷气式大脑（aka JetBrains）的一句宣传语。虽然目前无论是工作还是自己的项目里我用的都是 VSCode，但是毕竟大学编程的一大半时间都是在 JetBrains 家的各种 IDE 中度过的（毕竟有学生免费），所以对它家印象还是比较深的。第一次见到这句宣传语应该是在某次 ICPC 的直播上（当时 JetBrains 是官方赞助商之一），感觉直击心灵。在学校里的时候虽然有各种课程，但也有一些有趣的课程项目，再加上自己也会写点自己的东西，所以的确是有这种编程的动力的。这样的动力在工作后甚至也延伸了一段时间，上班的时候写公司的代码，下班之后忙自己的项目。&lt;/p&gt;
&lt;p&gt;可惜这样的动力并没有延伸太久。随着工作年限增长，工作上要处理的事务也越来越多，虽然也写代码，但是写代码的时间并不是工作时间的大头，因为还有无数的关联任务需要完成（设计文档、代码评审、发布、告警处理&amp;hellip;）。即使是到了周末，也会因为周中的工作几乎耗尽了精力，没有动力坐回电脑前写点什么；残存的精力已经只够我在床上躺着刷手机了，各种个人项目也因此停滞了很久。&lt;/p&gt;
&lt;p&gt;但各类 AI 代码编辑器（更准确地说，是 LLM-assisted programming?）的出现改变了这一切。虽然 ChatGPT 早在 22 年底就发布了，但是我自己亲自上手体验已经是 23 年初。当时还是刀耕火种的时代，需要自己从网页里复制代码到 IDE 里。后来 Github Copliot 有了对话模式，可以稍微做一些交互式的任务了，但是因为没法自动 apply changes，最多只能 insert，体验还是不太行。再后来试用了 Cursor，第一次体会到了什么叫做 “AI-Native” 的编辑体验，变更大部分时间都可以直接 Apply 进去，不用再自己一个个找了；但是用起来还是感觉有点迟滞，例如因为索引还不太好使，很多时候都得手动指定某一个特定的文件加入上下文才能有比较好的效果。最近我在使用的是 Windsurf，起初不是很习惯（生成过程中看不到进度，和 Cursor 不同），但后来才发现了其 agent 能力的真正作用，多文件修改、代码库索引，再结合自带的联网搜索，真正做到了指哪打哪，信手拈来。&lt;/p&gt;
&lt;p&gt;之前之所以空闲时间不太想写代码，并不是因为没有想法，而是虽然有想法，但是具体怎么实现的思路依然很模糊，而且中途还有高度的不确定性和时间成本，例如有的时候配环境就因为一些莫名其妙的依赖调试了两三个小时，或者是因为某一个感觉上很直接但是就是写不对的函数 rage quit。但是有了 LLM 之后，我可以直接对着编辑器说：去，把这个功能给我做出来，然后看着 agent 吭呲吭呲尝试各种方法，自己调试问题。虽然偶尔还是要人介入，但是心态上会好很多，感觉自己仿佛什么都能做。在我最近的一个小项目里，我给一个 Rust 的库实现了一个 web playground &lt;a href=&#34;https://github.com/yshavit/mdq/issues/230&#34;&gt;link&lt;/a&gt; 。虽然我知道步骤是先写一个 wrapper，然后编译 wasm，再写点 js 去调，但是里面有很多细节我是不知道的（需要装什么工具，怎么编译）或者是不想手动做的（例如写胶水前端代码）。于是我把我的思路告诉 LLM，一个小时之后我就有了一个能用的 demo。（其中甚至还包括至少二十分钟在等 rust toolchain 和 wasmpack 编译）这样的效率是之前自己想都不敢想的。&lt;/p&gt;
&lt;p&gt;但是我也注意到，AI 代码编辑器的出现，只是帮助让有想法的人走的更快更远；如果一开始就没有想法，即使有这样的工具也不会去用。以我自己为例，AI 音乐/图片/视频生成已经实用化很长时间了，也有各类免费的服务可供选用，但是我却提不太起去用它们创作些什么的兴趣，也没有什么想法。由此推知，可能也有其他人心中有不少想让 AI 画出来的画面，有 the drive to draw，但是面对空白的编辑器窗口却不知道应该发出什么指令，帮助自己做什么事情吧。&lt;/p&gt;
&lt;p&gt;最后，无论目标为何，希望大家都能找到自己趁手的工具，完成自己想做的事。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>游戏推荐 - A Short Hike</title>
      <link>https://nekonull.me/share/game-a-short-hike/</link>
      <pubDate>Tue, 04 Feb 2025 21:07:26 +0800</pubDate>
      
      <guid>https://nekonull.me/share/game-a-short-hike/</guid>
      <description>&lt;p&gt;我很少主动玩游戏。虽然有时会看其他人的游玩/剧情视频，但是自己实际上手玩的几乎没有。可能是小学的时候玩得足够多，长大之后反而对游戏失去了兴趣。我不想在竞技类游戏里比拼分数，也不想在策略类游戏里消耗脑力，更不想在吃操作的游戏里磨炼键位。日常生活已经够累了，何必再在游戏里自寻烦恼呢？但是 A Short Hike 让我体会到了不一样的感受。这是一个玩起来放松、甚至治愈的游戏。（用番剧类比的话，就像《摇曳露营》的第一季。）它让我如此惊喜，以至我甚至愿意专门写这篇短文来推荐。&lt;/p&gt;
&lt;p&gt;为什么它能有这样的神奇效果呢？我没法指出一个确切的原因，但是以下这些优点可能都有帮助。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主线直接、支线丰富：主线剧情很简单，正如其名，爬到山顶就完成了，一般 2h 内就可以完成。但主线之外，还有各种各样的支线任务（钓鱼、划船、赛跑&amp;hellip;），即使完成了主线，到了 end game 阶段也不会感到空虚；现在我依然会时不时打开，让自己放空一会。&lt;/li&gt;
&lt;li&gt;世界小、密度大：虽然游戏内的世界并不算大（一座大岛 + 几座小岛），但是地图设计很精致，跑图探索的时候会感觉每个方向都有事做。另外地图是完全开放的，想去哪就去哪，完全自由，不像一些开放世界游戏，需要完成前置任务或者是满足前置条件，才能解锁接下来的区域。&lt;/li&gt;
&lt;li&gt;操作友好、上手简单：作为游戏苦手，操作不是我的强项，但游戏内实际上只需要方向键移动和两个动作键（Z爬墙/滑翔，X操作工具），即使是很少玩游戏的我也能轻易上手；难度的渐进（通过耐力条金羽毛控制）也很合理，正常流程基本不会遇到卡关的情况，甚至还能探索出很多非预期解法；滑翔的体验非常棒，每次都让人意犹未尽。&lt;/li&gt;
&lt;li&gt;交互机制精妙：这里的交互指的是游戏内玩家和游戏世界的交互，而不是指用输入设备操作游戏；游戏内有一些特殊的工具（例如水桶、铲子）可以在多种场景下使用，而且非常直观，你觉得应该能行的操作很多时候还真能行。（甚至还有隐藏成就）&lt;/li&gt;
&lt;li&gt;对话有趣、角色立体：游戏没有配音，只有文字对话，且语句都很简短；但因为对话写的好，无论是主角，还是游戏里的其他 NPC 的形象都很立体，并不会觉得是普通的可以被任意替换的角色；甚至还有剧情弧光，一开始以为的坏人后来发现也有苦衷。&lt;/li&gt;
&lt;li&gt;画风独特、色彩明亮：用文字描述起来有些困难，去 Steam 页面看看预览图就懂了；像素大小可以根据自己的需要调整。&lt;/li&gt;
&lt;li&gt;音乐宁静：不同地区有自己的 BGM，而且是动态分层的，随着剧情进展会有变化；OST 已经加入我的歌单。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然优点很多，但是依然有一些小小的缺憾：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定视角：游戏内方向键只能操作主角的移动，视角方向是游戏自动切换的；虽然大部分情况下都很合理，但是有的时候自动切换会非常突兀。（明明移动方向不变，但是因为视角切换了，所以方向键输入也需要切换）&lt;/li&gt;
&lt;li&gt;没有游戏内地图：虽然玩的多会形成心理地图，但是还是会时不时迷路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总评：9/10 （神作）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个适合于&lt;strong&gt;所有人&lt;/strong&gt;的游戏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Steam 商店页面：&lt;a href=&#34;https://store.steampowered.com/app/1055540/A_Short_Hike/&#34;&gt;A Short Hike&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;原价 32 元，购入时 40% off，实际购入价格 19.2 元&lt;/li&gt;
&lt;li&gt;无官方简体中文支持，但是可以打社区补丁（英文用词不复杂，直接玩也行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作者在 GDC 上的回顾演讲：&lt;a href=&#34;https://www.youtube.com/watch?v=ZW8gWgpptI8&#34;&gt;Crafting A Tiny Open World: A Short Hike Postmortem&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;说起来这个游戏进入我的视野，是因为 YouTube 向我推荐了这个视频；即使没有时间玩游戏，这个视频依然很有趣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对音乐的分析：&lt;a href=&#34;https://www.youtube.com/watch?v=PCtQFf6us0c&#34;&gt;Musical Maps in A Short Hike (feat. Mark Sparling)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线地图：&lt;a href=&#34;https://voxelse.github.io/aShortHike/interactiveMap/&#34;&gt;Interactive Map - A Short Hike&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>读书记录《悟道领域驱动设计》</title>
      <link>https://nekonull.me/share/book-ddd/</link>
      <pubDate>Sun, 05 Jan 2025 23:38:12 +0800</pubDate>
      
      <guid>https://nekonull.me/share/book-ddd/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;ch2 应用架构
&lt;ul&gt;
&lt;li&gt;贫血模型 vs 充血模型
&lt;ul&gt;
&lt;li&gt;贫血模型：类只是数据容器，没有行为（例如 pojo）&lt;/li&gt;
&lt;li&gt;充血模型：类有属性（数据），也有方法（行为）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;项目结构
&lt;ul&gt;
&lt;li&gt;接口层：对外暴露api/消息consumer&lt;/li&gt;
&lt;li&gt;应用服务层：协调领域模型完成业务逻辑&lt;/li&gt;
&lt;li&gt;基础设施层：写db/缓存/调外部服务&lt;/li&gt;
&lt;li&gt;领域层：领域内的具体逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查询的两种实现
&lt;ul&gt;
&lt;li&gt;1 读数据后加载领域模型（聚合根），聚合根转换为查询结果 view&lt;/li&gt;
&lt;li&gt;2 直接用实际存储的数据模型，跳过领域对象加载，直接用把数据模型转换为查询结果 view&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch3 实体和值对象
&lt;ul&gt;
&lt;li&gt;实体：有唯一标识的领域模型
&lt;ul&gt;
&lt;li&gt;e.g. 内容发布系统的文章&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;值对象：没有唯一标识，需要的时候随时构造，值一样就认为是相同的对象
&lt;ul&gt;
&lt;li&gt;e.g. 内容发布系统的文章标题&lt;/li&gt;
&lt;li&gt;DP：Domain Primitive 领域内的基本数据类型，值对象的一种
&lt;ul&gt;
&lt;li&gt;e.g. 金融系统中的金额（money）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch4 聚合与聚合根
&lt;ul&gt;
&lt;li&gt;聚合：一组对象组成的对象树
&lt;ul&gt;
&lt;li&gt;单个实体也是聚合&lt;/li&gt;
&lt;li&gt;聚合是一致性的边界；聚合内强一致，跨聚合最终一致
&lt;ul&gt;
&lt;li&gt;一个事务只更新单个聚合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;聚合根：这个对象树的入口
&lt;ul&gt;
&lt;li&gt;单个实体也可以是聚合根&lt;/li&gt;
&lt;li&gt;外部对象只能引用聚合根（通常通过持有一个id）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拆分聚合
&lt;ul&gt;
&lt;li&gt;一个实体被多个聚合根引用，应该被提升为聚合根&lt;/li&gt;
&lt;li&gt;1:N 的集合属性（Role-Resource Binding），因为存在双向查找的需要（Role找Resource，Resource找Role），通常也可能被提升为聚合根&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch5 Factory, Repo, 领域服务
&lt;ul&gt;
&lt;li&gt;Factory：从无到有创建领域对象
&lt;ul&gt;
&lt;li&gt;需要分配 id&lt;/li&gt;
&lt;li&gt;通常用 builder 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Repo：保存和加载聚合根，和实际的存储解耦
&lt;ul&gt;
&lt;li&gt;save：聚合根持久化到数据库
&lt;ul&gt;
&lt;li&gt;注意事务控制，所有实际的写操作应该在一个事务内执行（例如文章写一个表，文章内容写另一个表）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;load：从数据库查询数据对象，组装回聚合根&lt;/li&gt;
&lt;li&gt;推荐实现行级 repo，一个聚合根对应数据库中一行数据
&lt;ul&gt;
&lt;li&gt;如果存在查多行的需求，如 queryList，应该用 CQRS 分离出去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;领域服务：包含领域中不适合放在实体/值对象的业务操作，应该是无状态的
&lt;ul&gt;
&lt;li&gt;例子：导出数据为 excel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch6 设计模式
&lt;ul&gt;
&lt;li&gt;责任链：多个handler逐个执行&lt;/li&gt;
&lt;li&gt;策略：从多种算法实现中选择一个（根据业务类型匹配到策略）&lt;/li&gt;
&lt;li&gt;桥接&lt;/li&gt;
&lt;li&gt;规约：验证复杂规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch7 防腐层 ACL
&lt;ul&gt;
&lt;li&gt;避免外部系统变更影响到当前系统（字段名变化、包名变化&amp;hellip;）&lt;/li&gt;
&lt;li&gt;实现：适配器模式
&lt;ul&gt;
&lt;li&gt;出入参数应该是本地值对象，或者基本数据类型&lt;/li&gt;
&lt;li&gt;外部异常/错误码应该转换为本地异常/错误码&lt;/li&gt;
&lt;li&gt;只返回实际需要的字段&lt;/li&gt;
&lt;li&gt;一般在应用服务/领域服务调用防腐层，不要在实体和值对象使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch8 领域事件
&lt;ul&gt;
&lt;li&gt;幂等实现：数据库唯一索引 /  状态机&lt;/li&gt;
&lt;li&gt;事件建模：用领域语言（例如账户被激活）；建模为值对象/贫血对象（不可变的）&lt;/li&gt;
&lt;li&gt;应用
&lt;ul&gt;
&lt;li&gt;触发其他领域/聚合的行为&lt;/li&gt;
&lt;li&gt;记录状态变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件消息体：实体id，事件id，事件类型，发生事件
&lt;ul&gt;
&lt;li&gt;也可选包含具体数据，减少查询需要，例如用户变更手机号事件带上新的手机号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生成事件
&lt;ul&gt;
&lt;li&gt;应用层创建：推荐，直接在应用层生成，然后调用基础服务发布&lt;/li&gt;
&lt;li&gt;聚合根创建：聚合根内生成事件，存储在聚合根内一个临时位置，应用层调用方法从聚合根取得，然后调用基础服务进行发布&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;发布事件
&lt;ul&gt;
&lt;li&gt;问题：保存聚合根和发布领域事件应该是一个事务，不能一个失败一个成功；但是引入分布式事务会造成复杂度上升&lt;/li&gt;
&lt;li&gt;解决：用一个db里事件表，repo save的时候不仅写聚合根，还写事件表；然后用事件表变更触发mq
&lt;ul&gt;
&lt;li&gt;轮询补偿：一个外部定时任务，检查事件表中状态=未发布的事件，读出来发mq，然后更新状态为已发布&lt;/li&gt;
&lt;li&gt;拖尾：用一个db拖尾组件监听db变更，自动发布到mq&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;订阅事件：事件 consumer 作为一个新的接口层，调用应用层服务
&lt;ul&gt;
&lt;li&gt;注意幂等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch9 CQRS
&lt;ul&gt;
&lt;li&gt;问题：查询的时候加载聚合根可能没必要（例如只读取一部分字段）；但是修改的时候必须要加载完整聚合根&lt;/li&gt;
&lt;li&gt;CQRS 应用层分为 查询 query 和 修改 command 两部分，分别用不同的模型处理
&lt;ul&gt;
&lt;li&gt;command 依然加载完整聚合根&lt;/li&gt;
&lt;li&gt;query 直接用数据模型（db数据）进行查询，转换为需要的返回 view&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现
&lt;ul&gt;
&lt;li&gt;同数据源：比较简单，query 不用 repo.load 而是直接读db&lt;/li&gt;
&lt;li&gt;异数据源：复杂，可能导致不一致
&lt;ul&gt;
&lt;li&gt;需求：主数据存储 mysql，用 es 做文本搜索&lt;/li&gt;
&lt;li&gt;实现：应用层发布领域事件，db日志拖尾&lt;/li&gt;
&lt;li&gt;查询可以是一个贫血模型，因为没有复杂逻辑且只读数据不修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：复杂度高、可能导致数据一致性问题、增加学习成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch10 事件溯源
&lt;ul&gt;
&lt;li&gt;想法：存储领域事件，读取时通过重放领域事件得到最新聚合状态
&lt;ul&gt;
&lt;li&gt;优点：完整业务跟踪能力；可以回滚到任意时刻的聚合根&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现1：最原始的实现，直接存领域事件，读时回放
&lt;ul&gt;
&lt;li&gt;只有一个事件表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现2：事件多查起来慢，因此加快照，回放时用 上次快照 + 上次快照后的事件
&lt;ul&gt;
&lt;li&gt;事件表 + 快照表，save的时候可能需要生成快照&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现3：快照表用拉链表实现，存储所有事件+聚合根所有版本（含有效期）
&lt;ul&gt;
&lt;li&gt;拉链表：含有开始时间和结束时间，表明这一行数据在此时间段内有效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch11 一致性
&lt;ul&gt;
&lt;li&gt;聚合内一致性
&lt;ul&gt;
&lt;li&gt;事务应该在 repo 实现，不应该在应用层实现，否则会造成事务过大&lt;/li&gt;
&lt;li&gt;用乐观锁避免并发更新问题&lt;/li&gt;
&lt;li&gt;repo save 失败，需要在应用层重试，来确保聚合数据是最新状态（即重新 load）
&lt;ul&gt;
&lt;li&gt;因为会重新调用外部接口，依赖的外部接口应该幂等&lt;/li&gt;
&lt;li&gt;不适合频繁更新的热点数据（可能导致频繁重试）&lt;/li&gt;
&lt;li&gt;重试次数规划好，一般一次就够了，多次的话应该考虑其他架构&lt;/li&gt;
&lt;li&gt;重试次数/触发原因可配置，一般只有乐观锁失败再重试，其他错误不应该重试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读写性能问题
&lt;ul&gt;
&lt;li&gt;一般业务做不到那么大&lt;/li&gt;
&lt;li&gt;读多写少：读写分离、缓存、复杂查询维护单独的读数据源、分库分表&lt;/li&gt;
&lt;li&gt;写之前的确需要完整加载聚合，写慢点就忍吧&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跨聚合一致性：实际上是分布式事务
&lt;ul&gt;
&lt;li&gt;二阶段提交：prepare, commit；commit 可能失败，此时rollback
&lt;ul&gt;
&lt;li&gt;代价比较大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地消息表+发布领域事件：见 ch8&lt;/li&gt;
&lt;li&gt;最大努力通知：上游不断发起通知调用给下游，直到下游确认
&lt;ul&gt;
&lt;li&gt;适用于对可靠性要求不高&lt;/li&gt;
&lt;li&gt;发起者需要提供查单接口，供接收者主动查询状态&lt;/li&gt;
&lt;li&gt;发起者需要实现重复通知，接收者自己保证幂等&lt;/li&gt;
&lt;li&gt;发通知间隔应该指数退避，且限制最大次数，避免无限发送&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TCC：try, confirm, cancel；try成功了confirm必须成功
&lt;ul&gt;
&lt;li&gt;注意点1 幂等：confirm/cancel幂等&lt;/li&gt;
&lt;li&gt;注意点2 空回滚：没有调用try就调用了cancel；收到cancel查资源状态，没try过应该直接返回&lt;/li&gt;
&lt;li&gt;注意点3 事务悬挂：先执行cancel再执行try；收到try查资源状态，被cancel过也直接返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;saga：正向perform，补偿compensate
&lt;ul&gt;
&lt;li&gt;注意点1 隔离性：正向操作完成后，其他事务已经能观察到了，负向回滚之后可能影响到其他事务（用户看到订单消失）
&lt;ul&gt;
&lt;li&gt;考虑引入一个中间状态例如 pending&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意点2 幂等：perform/compensate 都应该幂等&lt;/li&gt;
&lt;li&gt;注意点3 空回滚：没有perform就compensate；补偿前用业务主键查是否有perform，没有直接返回，并记录已回滚&lt;/li&gt;
&lt;li&gt;注意点4 事务悬挂：先compensate再perform；perform前查询是否compensate过，有则报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选型
&lt;ul&gt;
&lt;li&gt;不要求实时，只要求最终一致：本地消息表、最大努力通知&lt;/li&gt;
&lt;li&gt;要求实时：TCC&lt;/li&gt;
&lt;li&gt;长事务、涉及外部/遗留系统：saga&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch12 战略设计
&lt;ul&gt;
&lt;li&gt;概念
&lt;ul&gt;
&lt;li&gt;限界上下文：一个特定业务内的概念、规则、流程
&lt;ul&gt;
&lt;li&gt;如电商系统中的订单、商品、营销、物流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上下文映射：不同限界上下文之间的协作关系&lt;/li&gt;
&lt;li&gt;子域：关联性强的限界上下文形成的大的业务概念
&lt;ul&gt;
&lt;li&gt;主播+直播 -&amp;gt; 视频直播子域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;划分限界上下文：按照业务边界&lt;/li&gt;
&lt;li&gt;上下文映射
&lt;ul&gt;
&lt;li&gt;共享内核：存在共享的代码、领域模型、基础设施等&lt;/li&gt;
&lt;li&gt;客户 供应商：客户（下游）给供应商（上游）提要求，如加接口、加字段&lt;/li&gt;
&lt;li&gt;跟随者：上游不响应下游要求，下游得自己做&lt;/li&gt;
&lt;li&gt;各行其道：上下游完全不关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子域类型
&lt;ul&gt;
&lt;li&gt;核心子域：业务系统最重要的部分，业务价值高&lt;/li&gt;
&lt;li&gt;支撑子域：起到支撑作用，但是没有成熟/通用方案，需要自己构建&lt;/li&gt;
&lt;li&gt;通用子域：有通用性，存在成熟/通用方案，可以通过采购/开源获得&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch13 领域建模
&lt;ul&gt;
&lt;li&gt;事件风暴法：收集所有领域事件，归纳领域模型&lt;/li&gt;
&lt;li&gt;收集内容
&lt;ul&gt;
&lt;li&gt;领域事件&lt;/li&gt;
&lt;li&gt;命令：触发领域事件&lt;/li&gt;
&lt;li&gt;actor：命令的人为发起者&lt;/li&gt;
&lt;li&gt;策略：命令的规则发起者，满足某种条件自动触发；定时任务也算&lt;/li&gt;
&lt;li&gt;外部系统：也是命令的发起者&lt;/li&gt;
&lt;li&gt;聚合&lt;/li&gt;
&lt;li&gt;读模型：actor 发起命令前读的数据（例如审核员查看内容），需要这些数据辅助决策&lt;/li&gt;
&lt;li&gt;热点：待定问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建模流程
&lt;ul&gt;
&lt;li&gt;列举领域事件&lt;/li&gt;
&lt;li&gt;按业务流程排序领域事件；无法连接的说明可能遗漏了&lt;/li&gt;
&lt;li&gt;补充命令&lt;/li&gt;
&lt;li&gt;补充发起者&lt;/li&gt;
&lt;li&gt;提取聚合：同一个聚合的领域事件归类到一起&lt;/li&gt;
&lt;li&gt;补充读模型&lt;/li&gt;
&lt;li&gt;划分限界上下文，标注映射关系；注意需要标记上下游&lt;/li&gt;
&lt;li&gt;划分子域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch14 研发效能
&lt;ul&gt;
&lt;li&gt;maven 脚手架&lt;/li&gt;
&lt;li&gt;响应封装 graceful response&lt;/li&gt;
&lt;li&gt;对象转换 mapstruct&lt;/li&gt;
&lt;li&gt;静态分析&lt;/li&gt;
&lt;li&gt;低代码&lt;/li&gt;
&lt;li&gt;持续集成/持续交付/持续部署&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch15 测试驱动开发 tdd
&lt;ul&gt;
&lt;li&gt;红绿循环：写测试、测试失败、写代码、测试通过、重构、测试通过&lt;/li&gt;
&lt;li&gt;贫血模式的 tdd
&lt;ul&gt;
&lt;li&gt;dao：生成的，一般不用测&lt;/li&gt;
&lt;li&gt;service：对基础设施的调用应该 mock&lt;/li&gt;
&lt;li&gt;controller：mockmvc 直接测试 http 请求，验证响应（如返回码）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ddd 中的 tdd
&lt;ul&gt;
&lt;li&gt;实体：测全分支；不应该依赖启动容器和基础设施&lt;/li&gt;
&lt;li&gt;值对象：覆盖业务规则&lt;/li&gt;
&lt;li&gt;factory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch16 敏捷开发
&lt;ul&gt;
&lt;li&gt;scrum&lt;/li&gt;
&lt;li&gt;看板&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch17 架构可视化
&lt;ul&gt;
&lt;li&gt;c4 模型
&lt;ul&gt;
&lt;li&gt;系统上下文图：只展示核心系统、支持元素（如外部依赖、用户）&lt;/li&gt;
&lt;li&gt;容器图：展示主要数据选型和个容器的职责分工
&lt;ul&gt;
&lt;li&gt;容器：可独立运行/部署的单元（如后台单体、缓存、数据库）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组件图：展示可执行容器内部分工，指导开发&lt;/li&gt;
&lt;li&gt;代码图：UML/ER图，不推荐画（变更频繁）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他图
&lt;ul&gt;
&lt;li&gt;系统全景图：展示关联的所有系统&lt;/li&gt;
&lt;li&gt;动态图：展示元素在运行时如何协作，用箭头和编号表示顺序&lt;/li&gt;
&lt;li&gt;部署图：说明部署方案，含有实例数量、机房等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch18 重构
&lt;ul&gt;
&lt;li&gt;模式
&lt;ul&gt;
&lt;li&gt;修缮者：实现新方法，保留老方法，用开关切换，无问题后删除老方法&lt;/li&gt;
&lt;li&gt;绞杀者：设计新系统，用一个门面承接流量，逐渐在新系统实现功能，并切老系统的流量到新系统，直到老系统完全无流量&lt;/li&gt;
&lt;li&gt;推翻重建：彻底放弃老系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流程
&lt;ul&gt;
&lt;li&gt;启动
&lt;ul&gt;
&lt;li&gt;必要性评估：考虑性能、可靠性、技术栈、业务支持、研发效率、运营效率&lt;/li&gt;
&lt;li&gt;环境因素：企业战略、组织架构稳定性、文化氛围、管理风格&lt;/li&gt;
&lt;li&gt;效益和风险分析&lt;/li&gt;
&lt;li&gt;可行性分析：天时（和企业战略一致）、地利（已具备环境条件）、人和（团队愿意支持思想一致）&lt;/li&gt;
&lt;li&gt;干系人识别：团队成员、管理者、职能部门负责人、最终用户&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;规划
&lt;ul&gt;
&lt;li&gt;确认重构范围&lt;/li&gt;
&lt;li&gt;工作任务分解：任务分给唯一的某个人完成，可以向其他组员寻求帮助，但是负责人只有一个&lt;/li&gt;
&lt;li&gt;工期估算和进度计划&lt;/li&gt;
&lt;li&gt;沟通计划：管理层、项目成员、外部团队&lt;/li&gt;
&lt;li&gt;人力资源计划：人力不足需要申请人力、提前培训&lt;/li&gt;
&lt;li&gt;质量管理计划：业务流程梳理用力、数据一致性对比&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行
&lt;ul&gt;
&lt;li&gt;组建团队&lt;/li&gt;
&lt;li&gt;梳理现有业务逻辑：读代码、读历史文档、头脑风暴&lt;/li&gt;
&lt;li&gt;整理用例并评审&lt;/li&gt;
&lt;li&gt;实施开发：DDD、敏捷、测试驱动、CICD&lt;/li&gt;
&lt;li&gt;数据迁移&lt;/li&gt;
&lt;li&gt;灰度切量&lt;/li&gt;
&lt;li&gt;老系统下线：老系统可能还有调用者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;监控
&lt;ul&gt;
&lt;li&gt;进度&lt;/li&gt;
&lt;li&gt;质量&lt;/li&gt;
&lt;li&gt;待办项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收尾
&lt;ul&gt;
&lt;li&gt;沉淀过程资产：架构图、FAQ、接口文档&lt;/li&gt;
&lt;li&gt;推动新系统普及：通知调用方&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据迁移的实现
&lt;ul&gt;
&lt;li&gt;方案1：双写
&lt;ul&gt;
&lt;li&gt;步骤1：老系统开始写入新数据源；新系统需要支持写老数据源&lt;/li&gt;
&lt;li&gt;步骤2：历史数据从老数据源全量迁移到新数据源；检查新老数据一致性&lt;/li&gt;
&lt;li&gt;步骤3：读验证，灰度部分读流量到新系统&lt;/li&gt;
&lt;li&gt;步骤4：写验证，灰度部分写流量到新系统（新系统依然写老数据源，且定期校验）&lt;/li&gt;
&lt;li&gt;步骤5：全部流量切换到新系统，新系统双写老数据源&lt;/li&gt;
&lt;li&gt;步骤6：新系统稳定后，关闭新系统写老数据源开关，老系统下线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方案2：双向数据同步
&lt;ul&gt;
&lt;li&gt;正向：老-&amp;gt;新：传输老系统的所有数据&lt;/li&gt;
&lt;li&gt;反向：新-&amp;gt;老：只传输新系统生成的数据（对来自老系统的数据有特殊标记）&lt;/li&gt;
&lt;li&gt;步骤：正向链路一直打开，全量数据从老系统迁移到新系统，且保证增量同步；写验证前打开反向链路，直到老系统下线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ch19 布道领域驱动设计
&lt;ul&gt;
&lt;li&gt;编码指南&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2024 年末杂谈</title>
      <link>https://nekonull.me/posts/end-of-2024/</link>
      <pubDate>Wed, 01 Jan 2025 15:57:31 +0800</pubDate>
      
      <guid>https://nekonull.me/posts/end-of-2024/</guid>
      <description>&lt;p&gt;其实本来昨晚就想写了，但是因为工作安排需要线上值班，所以今天才动笔。2024 终于平安结束了，希望 2025 年也能一切顺利吧。&lt;/p&gt;
&lt;h2 id=&#34;回顾-2024&#34;&gt;回顾 2024&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工作
&lt;ul&gt;
&lt;li&gt;继续干着，职级正常升了一级；不过后续再往上升估计就比较慢了，得慢慢熬&lt;/li&gt;
&lt;li&gt;做了一些更复杂的工作，还有几个大的跨部门项目&lt;/li&gt;
&lt;li&gt;前半年被迫在一个不熟悉的领域干了很久，好在后半年回到了原来的业务&lt;/li&gt;
&lt;li&gt;出了一个事故，好在影响不大；但是更提醒自己得谨慎再谨慎了&lt;/li&gt;
&lt;li&gt;总体而言没有太大变化，不具体展开了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;学习 &amp;amp; 阅读
&lt;ul&gt;
&lt;li&gt;年中考过了&lt;a href=&#34;https://nekonull.me/posts/ruankao-architect/&#34;&gt;软考高级系统架构师&lt;/a&gt;；然而除了拿了一个实体证书，目前还没有起到什么作用&lt;/li&gt;
&lt;li&gt;年底去考了 N2，不过实际上也没怎么学习，几乎是裸考了，应该是不可能过的&lt;/li&gt;
&lt;li&gt;今年读了 7 本书，但是主要都是技术类的，非技术类的读的不多；印象深刻的是 《软件设计的哲学》（link），把一些工作上隐约能感受到但是想不明白的点给理清楚了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开源 &amp;amp; 写作 &amp;amp; 探索
&lt;ul&gt;
&lt;li&gt;更新了 12 篇博客，入选了 2 次阮老师的周刊&lt;/li&gt;
&lt;li&gt;开源项目 mainonly 在 Github 上有 172 个 star，也成为了自己日常不可或缺的工具&lt;/li&gt;
&lt;li&gt;书签增加了 326 条；新增了&lt;a href=&#34;https://nekonull.me/posts/llm_x_bookmark/&#34;&gt;基于 LLM 的自动摘要 workflow&lt;/a&gt; ，未来找起来会方便一些&lt;/li&gt;
&lt;li&gt;开了一个微信公众号，把部分内容同步了过去；甚至收到了一位读者的赞赏，虽然金额不大，但还是很开心&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jerrylususu/advent-of-code-2024&#34;&gt;Advent Of Code 2024&lt;/a&gt;：49/50，24p2 放弃了；发现自己对这类项目容易上头，很容易把下班后的时间全放在解题上了，还是心态不太行&lt;/li&gt;
&lt;li&gt;LLM 相关
&lt;ul&gt;
&lt;li&gt;尝试完全把 LLM 融入工作流，写了一些自用的小工具&lt;/li&gt;
&lt;li&gt;Cursor 开发起来还是很爽的，模板类代码都可以代劳了，有足够好的注释/变量名生成的自动补全也非常靠谱，但是遇到一些复杂的逻辑问题时还是会卡住（可能是我用的模型能力问题？）&lt;/li&gt;
&lt;li&gt;不同的模型用多了会感觉有不同的性格，GPT 就比较简洁直接，Claude 虽然想得多但是有的时候会把方案做的太复杂；deepseek 就比较平衡，而且最重要的是便宜大碗，用起来不心疼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生活
&lt;ul&gt;
&lt;li&gt;今年出去旅游了 2 次：4 月清明假期去上海见了高中和大学同学，8 月&lt;a href=&#34;https://nekonull.me/archive/2408-huizhou-layflat/&#34;&gt;去惠州海边试了下躺平生活&lt;/a&gt;；然而总体还是没有太多出门的动力&lt;/li&gt;
&lt;li&gt;建立了工作日中午运动的习惯：一般就是在公司健身房，边踩椭圆机边补番，一次25min，约350kcal；运动完用 app 打下卡，还是挺有成就感的；看了下数据今年有 162 次运动记录，大概是工作日的 80%&lt;/li&gt;
&lt;li&gt;从家里搬出来住：10 月底搬到了一个离公司比较近（一站地铁，可以步行）的位置，虽然新增了房租的开销，但是因为几乎没有通勤问题，生活质量极大提升，总体还是很值得的&lt;/li&gt;
&lt;li&gt;更频繁的约饭：基本维持了一个月约一次饭的频率，不至于太频繁让人喘不过气，也不会太久以至于忘记之前聊了啥；对维持精神稳定很有帮助&lt;/li&gt;
&lt;li&gt;更多文字记录：工作上&lt;a href=&#34;https://nekonull.me/share/obsidian-work-journal/&#34;&gt;用 Obsidien 写任务笔记&lt;/a&gt;，基本没有再遗漏过细节了，效率极大提升；尝到甜头之后开始在生活里也记录更多东西，无论是每次约饭聊了啥，还是每周有什么有趣/有意思的事情。如果不记录，很快就忘记发生过什么了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;投资
&lt;ul&gt;
&lt;li&gt;今年开了股票账户；9月底的大涨没敢投入太多，因此也没赚多少，但好在最后没亏；实际体验过之后发现这种快进快出的风格还是不太适合自己，更习惯于一次买入就长久放着&lt;/li&gt;
&lt;li&gt;总体年化收益率 2.3%，按收益率排行：公司股票 &amp;gt; A股 &amp;gt; 美元存款 &amp;gt; 人民币货币基金&lt;/li&gt;
&lt;li&gt;被动收入（低风险无需操作的投资收益）基本达成了目标，一年的收益足够在房租低的城市完全躺平一年，但是安全边际还是太低了，还得努力提高投资水平&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;展望-2025&#34;&gt;展望 2025&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工作
&lt;ul&gt;
&lt;li&gt;希望能不出事故，继续干下去&lt;/li&gt;
&lt;li&gt;探索其他的工作机会（私企 &amp;amp; 体制内），考虑后路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术
&lt;ul&gt;
&lt;li&gt;用 LLM 学更多&lt;/li&gt;
&lt;li&gt;用 LLM 构建更多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生活
&lt;ul&gt;
&lt;li&gt;继续保持运动习惯&lt;/li&gt;
&lt;li&gt;每个季度读一本无关工作的书&lt;/li&gt;
&lt;li&gt;学习日语到 N2 水平&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;投资
&lt;ul&gt;
&lt;li&gt;进一步分散投资&lt;/li&gt;
&lt;li&gt;不亏钱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>不要在 gcc 7 里隐式捕获 constexpr 数组</title>
      <link>https://nekonull.me/share/gcc-constexpr-lambda-bug/</link>
      <pubDate>Sat, 02 Nov 2024 15:38:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/gcc-constexpr-lambda-bug/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;如果你还没有遇到过 compiler bug，说明你写的代码还不够多。 —— 一位本科同学&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;虽然经常能看到其他人遇到 compiler 导致的意外现象，自己遇到却还是第一次，因此还是写篇文章小小记录下。&lt;/p&gt;
&lt;p&gt;因为一些原因，目前工作中使用的 gcc 版本是 7.4。接到一个业务需求，需要对某些特定的用户打开一个 feature flag，且需要在代码里硬编码。代码很快就写完了，自测的时候却发现不太对劲。相关代码简化脱敏后如下所示。逻辑很简单，就是把可以进入灰度的用户 id 放到了一个 allowlist 里，然后检查当前的请求涉及到的所有用户 id 是否都在这个 allowlist 中。奇怪之处在于，在 gcc 7.4 下，如果用了 &lt;code&gt;std::any_of&lt;/code&gt; 来找，即便用户不在灰度列表中，列表成员检查也会返回 true，导致意外的灰度进入；简单的 for 循环则没有这个问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// we want to check if all users is in allowlist (something like a feature flag)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; allowlist[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; users;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    users.push_back(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; basic_found &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;find(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;begin(allowlist), std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;end(allowlist), &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;end(allowlist);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;outside: basic_found=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; basic_found &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// should be false, as expected
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; some_found_anyof &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;any_of(users.begin(), users.end(), [&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;](&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; uid) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; found &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;find(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;begin(allowlist), std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;end(allowlist), uid) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;end(allowlist);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inside: uid=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; uid &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;, found=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; found &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; found;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;some_found_anyof=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; some_found_anyof &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// should be false; however in gcc 7.4 this outputs true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; some_found_manual &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; u: users) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;find(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;begin(allowlist), std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;end(allowlist), u) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;end(allowlist)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            some_found_manual &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;some_found_manual=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; some_found_manual &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// should be false, as expected
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为需求要的比较着急，就先用 for 循环替换了。后面有空的时候尝试继续简化代码，可以得到如下的最小复现 POC：定义一个 constexpr 数组，创建一个 lambda 表达式，用&lt;code&gt;[&amp;amp;]&lt;/code&gt;隐式捕获这个数组，最后在闭包中多次获取其地址；会惊喜的发现，每次获取的地址是不一样的！（可以在 Compiler Explorer 自己试试：&lt;a href=&#34;https://godbolt.org/z/qdTfP81xn&#34;&gt;https://godbolt.org/z/qdTfP81xn&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; arr[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;outside: addr=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;outside: addr=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;outside: addr=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;]() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inside: addr=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inside: addr=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inside: addr=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt;(arr) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;outside: addr=0x7ffc4b13dc24
outside: addr=0x7ffc4b13dc24
outside: addr=0x7ffc4b13dc24
inside: addr=0x7ffc4b13dbec
inside: addr=0x7ffc4b13dbf8
inside: addr=0x7ffc4b13dc04
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从生成的汇编中可以发现，在闭包里每次访问 arr 时候，其实都在栈上临时创建了一个副本，因此每次获取到的 arr 地址都是不一致的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        mov     DWORD PTR [rbp-36], 1
        mov     DWORD PTR [rbp-32], 2
        mov     DWORD PTR [rbp-28], 3
        lea     rax, [rbp-36]
	    ...ignored...
		mov     DWORD PTR [rbp-24], 1
        mov     DWORD PTR [rbp-20], 2
        mov     DWORD PTR [rbp-16], 3
        lea     rax, [rbp-24]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这也就能解释为什么之前在 &lt;code&gt;std::any_of&lt;/code&gt; 闭包里用 &lt;code&gt;std::find&lt;/code&gt; 会有问题了：其中作为参数的 &lt;code&gt;std::begin(allowlist)&lt;/code&gt;, &lt;code&gt;std::end(allowlist)&lt;/code&gt; 和最后一个用于比较的 &lt;code&gt;std::end(allowlist)&lt;/code&gt;，三个 allowlist 的地址都不一样，因此这个 &lt;code&gt;!=&lt;/code&gt; 判定始终会成功，表现上就是会认为用户总是在灰度列表中了。&lt;/p&gt;
&lt;p&gt;这是不是一个 compiler bug 呢？正如文章标题，我只是把这作为一个 unexpected behavior，因为编译器可以自行选择对 constexpr 的优化方式。我也尝试在 gcc bug report 数据库里进行了查找，但看起来没有人反馈过这个问题。&lt;/p&gt;
&lt;p&gt;最后是可能的绕过方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;升级 gcc 版本（gcc 8 及以上版本无此问题，7.5 及以下版本才有此问题）&lt;/li&gt;
&lt;li&gt;换用其他 compiler：clang, msvc 都无此问题&lt;/li&gt;
&lt;li&gt;不要用 constexpr，改用一般的 const&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;[&amp;amp;arr]&lt;/code&gt; 显式捕获 constexpr 数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;祝读到这里的各位以后都能少踩这类奇怪的坑吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>工具小站</title>
      <link>https://nekonull.me/share/pages-repo/</link>
      <pubDate>Mon, 07 Oct 2024 14:03:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/pages-repo/</guid>
      <description>&lt;p&gt;参考 &lt;a href=&#34;https://tools.simonwillison.net/&#34;&gt;tools.simonwillison.net&lt;/a&gt;，决定把所有单页纯前端应用全部放到到一个 repo 里，并且分配一个子域名；这样不用每个小工具都申请独立 repo + 配置 Github Actions 了。&lt;/p&gt;
&lt;p&gt;虽然目前还是没什么东西，但是还是欢迎来玩：&lt;a href=&#34;https://pages.nekonull.me/&#34;&gt;pages.nekonull.me&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 WebRecorder 和 MitmProxy 的图片手动抓取探索</title>
      <link>https://nekonull.me/share/manual-scraping-with-webrecorder-mitmproxy/</link>
      <pubDate>Mon, 07 Oct 2024 13:58:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/manual-scraping-with-webrecorder-mitmproxy/</guid>
      <description>&lt;p&gt;最近收到任务，需要从某个站点下载一系列图片。首先当然是 F12 看下网络请求。这是一个无限滚动的瀑布流，图片地址本身是随机的（看起来文件名像是 uuid），所以没法直接遍历图片地址；此外每次滚动到底，都会触发一个获取下一页图片地址的请求，参数传的还是游标而不是页数，这又断绝了直接构造分页请求（例如 &lt;code&gt;page=1&lt;/code&gt;）获取所有图片地址，再逐个拉取的念头。好在总图片数是有限的，大概在 2k 左右，每次下拉能拉回 50 条，所以手动抓取也不是不能接受。以下是两种手动抓取的思路。注：这里的手动抓取，指的是在浏览器前端通过模拟人类行为，无侵入且不对网站发起额外请求的抓取方式。&lt;/p&gt;
&lt;h2 id=&#34;前置准备ahk-翻页器&#34;&gt;前置准备：AHK 翻页器&lt;/h2&gt;
&lt;p&gt;一个简单的小工具，每隔一段时间自动按 page down 翻页（建议提前 zoom out 调小页面比例，这样滚动起来效率更高）&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;AHK 翻页器代码&lt;/summary&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-autohotkey&#34; data-lang=&#34;autohotkey&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;#Requires AutoHotkey v2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 创建一个 GUI&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;MyGui &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; Gui()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;MyGui&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Add(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Text&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x10 y10&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Auto Page Down:&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;toggle &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; MyGui&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Add(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Checkbox&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x10 y30 vToggleState&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Enable&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;MyGui&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;OnEvent(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Close&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; ExitApp())&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;MyGui&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Show()&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 设置全局变量以跟踪定时器状态&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;global keyHeld &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; false&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 定时器：每0.1秒检查一次开关状态&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;SetTimer(CheckToggleState, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 主循环&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;CheckToggleState()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;{&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    global keyHeld&lt;span style=&#34;color:#75715e&#34;&gt;  ; 声明 keyHeld 为全局变量&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    if (toggle&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Value) {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;        if (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;keyHeld) {&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;            ; 如果勾选了启用选项，并且哔哩哔哩窗口处于活动状态&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;            RandomDelayAndSendPageDown()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;            keyHeld &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; true&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;        }&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    } else {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;        if (keyHeld) {&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;            ; 如果没有勾选启用选项，停止按键操作&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;            keyHeld &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; false&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;        }&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    }&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 生成随机延迟并发送 Page Down 键&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;RandomDelayAndSendPageDown()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;{&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    ; 生成 500 到 1000 毫秒之间的随机延迟&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    RandomDelay &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; Random(&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    SetTimer(PressPageDown, RandomDelay)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; 按下 Page Down 键&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;PressPageDown()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;{&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    global keyHeld&lt;span style=&#34;color:#75715e&#34;&gt;  ; 声明 keyHeld 为全局变量&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    if (toggle&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Value) {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;        Send(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{PgDn}&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;        RandomDelayAndSendPageDown()&lt;span style=&#34;color:#75715e&#34;&gt;  ; 继续下一次按键&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    } else {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;        keyHeld &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; false&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    }&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/details&gt;
&lt;h2 id=&#34;思路1webrecorder&#34;&gt;思路1：WebRecorder&lt;/h2&gt;
&lt;p&gt;概述：用 WebRecorder 插件，录制网络请求（WebRecorder 插件会 hook 浏览器的 XMLHttpRequest 机制），dump 出 &lt;a href=&#34;https://en.wikipedia.org/wiki/WARC_%28file_format%29&#34;&gt;warc&lt;/a&gt;  (Web Archive）文件，然后再解析文件，从中提取 mime 类型为图片的文件（或者知道 URL 格式的话也可以用 URL 格式匹配）。&lt;/p&gt;
&lt;p&gt;限制：导出的时候存在文件大小限制（Chrome 下似乎是 2G，也取决于可用内存大小），总文件大小太大的话可能会有问题。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 Chrome 插件 &lt;a href=&#34;https://chromewebstore.google.com/detail/webrecorder-archivewebpag/fpeoodllldobpkbkabpblcfaogecpndd&#34;&gt;Webrecorder ArchiveWeb.page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;浏览器插件栏找到 Webrecorder，点击 Start Archiving&lt;/li&gt;
&lt;li&gt;跳转到需要抓取的网页&lt;/li&gt;
&lt;li&gt;打开翻页器，一直往下滚动&lt;/li&gt;
&lt;li&gt;完成后打开插件，点击 Stop Archiving&lt;/li&gt;
&lt;li&gt;点击插件界面内的 Home 按钮，找到刚才的 Archiving Session，点击 Download，下载一个 wacz 文件到本地&lt;/li&gt;
&lt;li&gt;修改扩展名为 zip，将其中的 archive/data.warc.gz 文件解压出来，得到 data.warc 文件&lt;/li&gt;
&lt;li&gt;运行如下 Python 脚本，解析 warc 文件，并从中提取图片内容&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;summary&gt;Python 解析 WARC 代码&lt;/summary&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; warcio.archiveiterator &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; ArchiveIterator
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; os
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; re
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 定义一个函数过滤掉不支持的字符&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sanitize_filename&lt;/span&gt;(filename):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 定义不允许的字符&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    invalid_chars &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;[&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/:*?&amp;#34;&amp;lt;&amp;gt;|]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 替换这些字符为空字符，或者可以替换为下划线 &amp;#34;_&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sanitized_filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sub(invalid_chars, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_&amp;#39;&lt;/span&gt;, filename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sanitized_filename
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 提取 WARC 文件中的图片、视频资源&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;extract_resources_from_warc&lt;/span&gt;(warc_file, output_dir):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(warc_file, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; stream:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; record &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; ArchiveIterator(stream):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; record&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;http_headers:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                content_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; record&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;http_headers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_header(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; content_type &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;image&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; content_type:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# 获取资源文件的 URL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; record&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rec_headers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_header(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;WARC-Target-URI&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    print(url)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# 获取资源文件内容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    content &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; record&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;content_stream()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# 确定文件扩展名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    ext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;jpg&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;image&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; content_type &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mp4&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;video&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; content_type &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ext:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;# 生成文件名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        sanitized_url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sanitize_filename(os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;basename(url))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(output_dir, sanitized_url) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ext
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;filename&amp;#34;&lt;/span&gt;, filename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;# 保存文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(filename, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(content)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Extracted: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;filename&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 示例用法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;warc_file &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data.warc&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;output_dir &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;extracted_resources&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;makedirs(output_dir, exist_ok&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;extract_resources_from_warc(warc_file, output_dir)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/details&gt;
&lt;h2 id=&#34;思路2mitmproxy&#34;&gt;思路2：MitmProxy&lt;/h2&gt;
&lt;p&gt;概述：安装 mitmproxy，设置浏览器代理指向 proxy，浏览时从响应中直接过滤出图片内容并保存到本地&lt;/p&gt;
&lt;p&gt;限制：似乎没什么限制&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 &lt;a href=&#34;https://docs.mitmproxy.org/stable/overview-installation/&#34;&gt;mitmproxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;保存以下 Python 脚本为 &lt;code&gt;save.py&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;summary&gt;mitmproxy save.py&lt;/summary&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; os
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; re
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; mitmproxy &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; ctx, http
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 定义文件保存目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;save_dir &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;saved_media&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 确保目录存在&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;exists(save_dir):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;makedirs(save_dir)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 定义一个正则表达式，匹配Windows非法的文件名字符&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sanitize_filename&lt;/span&gt;(filename: str) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; str:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 替换非法字符为下划线&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sub(&lt;span style=&#34;color:#e6db74&#34;&gt;r&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;[&amp;lt;&amp;gt;:&amp;#34;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;|?*]&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;_&amp;#39;&lt;/span&gt;, filename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;(flow: http&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;HTTPFlow):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 获取响应的Content-Type&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    content_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;headers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 判断是否为图片或视频类型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;image&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; content_type:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 获取文件扩展名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ext &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; content_type&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 从请求路径中尝试提取文件名，如果路径中没有文件名，则使用flow.id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        url_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; url_path:  &lt;span style=&#34;color:#75715e&#34;&gt;# 判断路径中是否包含文件扩展名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            raw_filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; url_path
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            raw_filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;host&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;_&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;ext&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 对文件名进行清理，确保符合Windows的文件名要求&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        safe_filename &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sanitize_filename(raw_filename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 确定完整的保存路径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        filepath &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(save_dir, safe_filename)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 记录日志，打印保存的文件名和URL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ctx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;info(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Saving file: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;filepath&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; from URL: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;url&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 保存文件内容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(filepath, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;content)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 打印成功保存的日志&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ctx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;info(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Saved &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;filepath&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/details&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;运行 mitmproxy&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 需要先 cd 到 save.py 所在的目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 可以添加 --mode upstream:http://localhost:7890 来指定上游代理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mitmweb -s save.py
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;设置浏览器，指向 mitmproxy 代理（可能你需要 &lt;a href=&#34;https://chromewebstore.google.com/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif&#34;&gt;proxy switchyomega&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;跳转到需要抓取的网页，打开翻页器&lt;/li&gt;
&lt;li&gt;滚动到底部，且所有图片加载完成后，需要抓取的图片应该都已经保存到本地了&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>如何手动 squash</title>
      <link>https://nekonull.me/share/how-to-manual-squash/</link>
      <pubDate>Mon, 07 Oct 2024 13:56:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/how-to-manual-squash/</guid>
      <description>&lt;p&gt;最近帮解决了一个因为提交流程不规范导致的诡异 Git 分支问题，特此记录下，以备后用。&lt;/p&gt;
&lt;p&gt;背景：主干分支 main，特性分支 feat，在特性分支上开发特性的时候，多次合入了主干分支（仅快进，没有合并冲突）；模拟的 Git 历史如下图所示，其中 &lt;code&gt;m*&lt;/code&gt; 是主干提交，&lt;code&gt;f*&lt;/code&gt; 是特性分支提交&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;* 5fb94b2 (HEAD -&amp;gt; main) m4
| * 83c6299 (feat) f3
| *   ff5c5af Merge branch &amp;#39;main&amp;#39; into feat
| |\
| |/
|/|
* | 1698c3c m3
* | 05199a8 m2
| * 68a7e1d f2
| * eb5b169 f1
|/
* ae79b7c m1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问题：如何把特性分支上的所有提交合并为一个提交？（类似于 squash 的 Merge 策略，但是手动做到这一点）&lt;/p&gt;
&lt;p&gt;思路：找到主干和特性分支的第一个分叉点，以此为基准生成 patch，然后在一个新分支上 apply patch 得到一个纯净的 commit。&lt;/p&gt;
&lt;p&gt;（非人工写作提示：以下是 LLM 根据我自己的笔记生成的内容。欢迎将反馈贴在评论区，这将决定我以后是否会更积极地使用 LLM 进行创作。）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在日常开发中，我们经常会遇到这样的问题：由于开发流程、代码审查或其他原因，特性分支（Feature Branch）和主干（Main Branch）上的提交记录混杂在一起，难以管理。为了让代码历史更为清晰、整洁，我们通常需要手动进行 &lt;code&gt;squash&lt;/code&gt; 操作，将特性分支上的多次提交合并成一个提交点。&lt;/p&gt;
&lt;p&gt;这篇文章将带你一步步了解如何手动进行 &lt;code&gt;squash&lt;/code&gt; 操作，并确保不丢失任何数据。这种方法适用于已经有部分提交合并进主干，并且历史记录较为复杂的场景。&lt;/p&gt;
&lt;h2 id=&#34;场景问题&#34;&gt;场景问题&lt;/h2&gt;
&lt;p&gt;假设你正在开发一个新功能，但在开发过程中，特性分支 &lt;code&gt;feat&lt;/code&gt; 和主干分支 &lt;code&gt;main&lt;/code&gt; 上的提交混杂在一起。这样一来，不仅使代码历史难以追溯，还会影响代码审查和后续维护。因此，我们希望将 &lt;code&gt;feat&lt;/code&gt; 分支上的所有提交整合成一个提交点，并保持代码历史的清晰度。&lt;/p&gt;
&lt;h2 id=&#34;前置准备工作&#34;&gt;前置准备工作&lt;/h2&gt;
&lt;p&gt;在进行操作前，我们需要做一些准备工作，确保不会出现数据丢失的风险：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建备份分支并推送到远程：&lt;/strong&gt; 在特性分支 &lt;code&gt;feat&lt;/code&gt; 上创建一个备份分支，并推送到远程仓库，以确保操作过程中的数据安全。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout feat
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout -b feat-backup
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git push origin feat-backup
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样，即使后续操作中出现意外，我们依然可以通过 &lt;code&gt;feat-backup&lt;/code&gt; 分支恢复数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;步骤详解&#34;&gt;步骤详解&lt;/h2&gt;
&lt;h3 id=&#34;1-确定变更点&#34;&gt;1. 确定变更点&lt;/h3&gt;
&lt;p&gt;首先，我们需要找到 &lt;code&gt;feat&lt;/code&gt; 分支和 &lt;code&gt;main&lt;/code&gt; 分支的&lt;strong&gt;最后一个重合点&lt;/strong&gt;（也就是 &lt;code&gt;main&lt;/code&gt; 分支中包含但 &lt;code&gt;feat&lt;/code&gt; 中不包含的最后一个提交）。这样我们就可以清晰地识别出哪些提交属于 &lt;code&gt;feat&lt;/code&gt;，而哪些提交是混杂进来的。&lt;/p&gt;
&lt;h4 id=&#34;如何找到变更点&#34;&gt;如何找到变更点？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用以下命令，找出 &lt;code&gt;feat&lt;/code&gt; 分支中第一个与 &lt;code&gt;main&lt;/code&gt; 分支分叉的提交：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git log --oneline main...feat --reverse --pretty&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;format:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%H&amp;#34;&lt;/span&gt; | head -n &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此命令将列出 &lt;code&gt;feat&lt;/code&gt; 分支中所有提交的哈希值（&lt;code&gt;commit hash&lt;/code&gt;），并按照时间顺序排列，其中 &lt;code&gt;head -n 1&lt;/code&gt; 取出第一个分叉点的哈希值，记为 &lt;code&gt;{first_diverge_commit}&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后使用以下命令查找 &lt;code&gt;main&lt;/code&gt; 与 &lt;code&gt;feat&lt;/code&gt; 最后一个重合点的哈希值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rev-list --parents -n &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;first_diverge_commit&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; --reverse | head -n &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;取命令结果的&lt;strong&gt;右边部分&lt;/strong&gt;，这就是 &lt;code&gt;main&lt;/code&gt; 和 &lt;code&gt;feat&lt;/code&gt; 的最后重合点，记为 &lt;code&gt;{last_share_commit}&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-计算差异patch&#34;&gt;2. 计算差异（Patch）&lt;/h3&gt;
&lt;p&gt;现在我们已经知道了 &lt;code&gt;main&lt;/code&gt; 分支和 &lt;code&gt;feat&lt;/code&gt; 分支的分叉点和最后重合点，我们可以提取出 &lt;code&gt;feat&lt;/code&gt; 中相对于 &lt;code&gt;main&lt;/code&gt; 的所有变更。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;git diff&lt;/code&gt; 生成差异文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git diff main feat &amp;gt; ~/my_patch
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 请将 &lt;code&gt;patch&lt;/code&gt; 文件存放在仓库目录外，例如 &lt;code&gt;~/my_patch&lt;/code&gt;，因为后续执行 &lt;code&gt;git reset&lt;/code&gt; 时会重置仓库目录内的所有文件，导致 &lt;code&gt;patch&lt;/code&gt; 文件丢失。&lt;/p&gt;
&lt;h3 id=&#34;3-回溯到最后重合点&#34;&gt;3. 回溯到最后重合点&lt;/h3&gt;
&lt;p&gt;接下来，我们要将当前 &lt;code&gt;feat&lt;/code&gt; 分支的状态回退到 &lt;code&gt;main&lt;/code&gt; 分支的最后重合点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git reset --hard &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;last_share_commit&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该命令将 &lt;code&gt;feat&lt;/code&gt; 分支的状态重置到 &lt;code&gt;{last_share_commit}&lt;/code&gt; 提交。&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;reset --hard&lt;/code&gt; 会丢失所有当前分支的更改，因此确保之前的 &lt;code&gt;patch&lt;/code&gt; 文件已备份。&lt;/p&gt;
&lt;h3 id=&#34;4-快进主干fast-forward-merge&#34;&gt;4. 快进主干（Fast-Forward Merge）&lt;/h3&gt;
&lt;p&gt;现在，我们需要让 &lt;code&gt;feat&lt;/code&gt; 分支快进（fast-forward）到主干 &lt;code&gt;main&lt;/code&gt; 的最新状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git merge main --ff-only
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;--ff-only&lt;/code&gt; 参数表示如果不能进行快进合并，则不会合并。这一步确保 &lt;code&gt;feat&lt;/code&gt; 分支的历史记录与 &lt;code&gt;main&lt;/code&gt; 分支保持一致。&lt;/p&gt;
&lt;h3 id=&#34;5-应用补丁apply-patch&#34;&gt;5. 应用补丁（Apply Patch）&lt;/h3&gt;
&lt;p&gt;回退和快进操作完成后，我们将 &lt;code&gt;feat&lt;/code&gt; 分支上原本存在的所有提交变更（即 &lt;code&gt;patch&lt;/code&gt; 文件）重新应用到当前分支。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git apply ~/my_patch
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;6-提交变更并推送&#34;&gt;6. 提交变更并推送&lt;/h3&gt;
&lt;p&gt;现在，我们可以创建一个新的提交，将 &lt;code&gt;feat&lt;/code&gt; 分支的所有变更整合到一个提交中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git add .
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git commit -m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Squashed all feature changes into a single commit.&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着，将 &lt;code&gt;feat&lt;/code&gt; 分支强制推送到远端，以确保远程仓库与本地分支一致：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git push origin feat --force
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过上述操作，我们成功地将 &lt;code&gt;feat&lt;/code&gt; 分支的所有提交整合成了一个提交点，并且与主干保持了清晰的历史记录。完整步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出特性分支和主干的分叉点与重合点。&lt;/li&gt;
&lt;li&gt;生成 &lt;code&gt;patch&lt;/code&gt; 文件保存变更。&lt;/li&gt;
&lt;li&gt;回溯到重合点并进行快进合并。&lt;/li&gt;
&lt;li&gt;应用 &lt;code&gt;patch&lt;/code&gt; 文件，合并所有更改。&lt;/li&gt;
&lt;li&gt;提交合并后的变更，并推送到远端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种手动 &lt;code&gt;squash&lt;/code&gt; 方法，你可以灵活地调整提交历史，确保代码库的整洁度和可读性。&lt;/p&gt;
&lt;h2 id=&#34;勘误&#34;&gt;勘误&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;感谢评论区 @Certseeds 的指正，第 2 步的 diff 计算指令错误地将 last_share_commit 作为了 diff 开始点，实际上应该为 main（主干分支）；原文已修复。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LLM x 书签收藏：摘要 &amp; 全文索引</title>
      <link>https://nekonull.me/posts/llm_x_bookmark/</link>
      <pubDate>Mon, 07 Oct 2024 13:52:00 +0800</pubDate>
      
      <guid>https://nekonull.me/posts/llm_x_bookmark/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;网上冲浪的时候，经常会遇到一些有趣的文章或者网站，让我有收藏起来以备后用的冲动（虽然绝大部分情况下都没有再用过）。然而一个人收藏未免有些太孤单了，因此自从 2021 年 5 月以来，我一直在使用一个名为 &lt;a href=&#34;https://github.com/osmoscraft/osmosmemo&#34;&gt;osmos::memo&lt;/a&gt; 的书签插件，将我的收藏直接记录到一个公开的 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-collection&#34;&gt;Github 存储库&lt;/a&gt;。这个插件的工作原理很简单，首先设置好 Github 的 token，然后每次点击收藏按钮都会在浏览器里临时 clone 一次，追加新收藏的条目到文件顶部，生成 commit 并提交，然后推送回 Github。但是这样简单的工作流程也十分有效，除了 token 过期的时候需要手动续期（过期前有 Github 自带的邮件提醒，所以基本上不会拖到最后），没有什么可以出错的空间，近三年半下来也已经帮我积累了 800+ 条目了。&lt;/p&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;然而目前的书签收藏流程中，依然会存在一些问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;书签指向的 URL 可能不再存在（例如某个博客的主人决定不再续费域名，或者是做了链接格式的调整），导致成为悬空的死链接&lt;/li&gt;
&lt;li&gt;目前的记录项只有书签的 URL、标题和可选的标签（而且我打标签的习惯不太好，光靠标签基本上不太能找到），导致查找的时候如果对关键词记忆不清楚，很有可能找不到&lt;/li&gt;
&lt;li&gt;书签里一大部分是长文章，时间一久很有可能忘记内容，如果只是临时找些东西，通读一次又略微有些费时费事，导致查找&amp;amp;引用效率下降。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;p&gt;为了解决这些问题，我建立了一个新的存储库 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary&#34;&gt;bookmark-summary&lt;/a&gt;。这个存储库可以视为现有书签存储库的辅助数据，其中包含了新增书签的 Markdown 格式全文、列表摘要、一句话总结，和现有存储库之间通过 Github Actions 联动。其工作原理如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我通过书签插件，在现有的书签存储库中新增了一个条目&lt;/li&gt;
&lt;li&gt;代码提交到主干，触发名为 &lt;code&gt;summarize&lt;/code&gt; 的 Github Actions（&lt;a href=&#34;https://github.com/jerrylususu/bookmark-collection/blob/main/.github/workflows/bookmark_summary.yml&#34;&gt;yml 工作流文件&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;Github Actions 执行，首先 checkout 书签存储库和摘要存储库，然后执行 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary/blob/main/process_changes.py&#34;&gt;process_changes.py&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;首先解析书签 README.md 文件，找到最近新增的条目标题和 URL&lt;/li&gt;
&lt;li&gt;将 URL 保存到 Wayback Machine&lt;/li&gt;
&lt;li&gt;输入 URL，使用 &lt;a href=&#34;https://jina.ai/reader/&#34;&gt;jina reader&lt;/a&gt; API 获取网址的 Markdown 全文，并保存到 &lt;code&gt;YYYYMM/{title}_raw.md&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入 URL，使用 LLM 生成列表摘要（prompt 在 &lt;code&gt;summarize_text&lt;/code&gt; 函数 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary/blob/main/process_changes.py#L80&#34;&gt;link&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;输入列表摘要，使用 LLM 生成一句话总结&lt;/li&gt;
&lt;li&gt;将列表摘要和一句话总结保存到 &lt;code&gt;YYYYMM/{title}.md&lt;/code&gt;（&lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary/blob/main/202410/2024-10-02-a-local-first-case-study-jakelazaroff.com.md&#34;&gt;效果示例&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;更新摘要存储库的 README.md，增加到摘要文件的链接&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Github Actions 提交变更到摘要存储库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的主要代码基本都是 Claude 和 GPT4o 写的，人肉做了一些小调整。后面随着使用又逐步发现了一些 bug，最近还用 o1-mini &lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary/issues/6&#34;&gt;修复了一个&lt;/a&gt;，算是真切感受到了 LLM 对生产力的巨大提升。目前摘要生成用的是深度求索的 deepseek-chat，便宜是真便宜（输入 1元/1M token，输出 2元/1M token，在这个场景下的成本基本上是每个月1元不到），效果也还算可以。&lt;/p&gt;
&lt;h2 id=&#34;未来&#34;&gt;未来&lt;/h2&gt;
&lt;p&gt;最后是一些已知问题，以及未来可能的优化方向。当然和其他所有项目一样，欢迎 fork &amp;amp; PR。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;列表摘要质量：可能是 prompt 的问题，列表摘要倾向于每个大点下面只列两个小点，且没有充分合并需要合并的论点；可能需要考虑进一步优化 prompt，或者换用其他模型（不过我拿便宜的模型都试了一轮，基本上都存在类似问题）&lt;/li&gt;
&lt;li&gt;数据结构化：目前摘要存储库下有个简单的 data.json，但是核心的摘要和全文内容依然是 Markdown 存储的，而不是 JSON 这类程序友好的结构化存储。可能需要考虑在 Markdown 之外另外维护一个 JSON，以备未来的查询。&lt;/li&gt;
&lt;li&gt;代码整理和重构：目前所有逻辑都混在一个大的 Python 文件里，修改和测试起来都很烦人（实际上没有特别好的办法手动测试，目前都得靠手动注释掉部分代码）。未来一个考虑是做重构（o1-mini也给出过比较好的重构结构）+补充测试；另一个是改进书签存储库和摘要存储库的交互方式，例如通过读 git log 或者是明确传递最近书签条目的方式来触发摘要生成，而不是靠目前读文件对比的方式&lt;/li&gt;
&lt;li&gt;向量搜索：目前虽然原文和摘要都存下来了，搜索却还是只能靠基本的文本匹配；可能可以考虑接个 embedding 模型自动生成下嵌入，存到一个 SQLite 数据库（或者用各种向量数据库 as a Service）；主要是查询的时候也得生成 embedding，英文还有小模型可以搞，中文的模型都太大了，没法直接在前端跑不依赖后端服务，这里还得再仔细想想。&lt;/li&gt;
&lt;li&gt;自动生成每周周报：&lt;del&gt;既然现在书签有时间信息，可以考虑每周新增的书签+原文+摘要全部往 LLM 扔，自动生成一个每周摘要，放在 Github Release 里（不过不知道有没有人愿意看就是了）&lt;/del&gt; (已完成，参见 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary/releases&#34;&gt;Releases&lt;/a&gt;，实现见 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary&#34;&gt;build_weekly_release.py&lt;/a&gt;，代码主要由 o1-mini 实现)&lt;/li&gt;
&lt;li&gt;改用更现代的工具链：例如 uv，以及把依赖写在 Python 代码头部（PEP 723 &lt;a href=&#34;https://packaging.python.org/en/latest/specifications/inline-script-metadata/#inline-script-metadata&#34;&gt;Inline Script Metadata&lt;/a&gt;）？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;我也想要&#34;&gt;我也想要&lt;/h2&gt;
&lt;p&gt;可以参考以下步骤，在自己的 Github 账户下部署一套类似的系统。（根据回忆写的，所以可能不太详尽）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参考 &lt;a href=&#34;https://github.com/osmoscraft/osmosmemo&#34;&gt;osmos::memo&lt;/a&gt; 的指引，初始化书签存储库（我的叫做 bookmark-collection），安装浏览器插件，并连接到 Github&lt;/li&gt;
&lt;li&gt;新建一个摘要存储库（我的叫做 bookmark-summary），并在其中添加一个空的 README.md 文件&lt;/li&gt;
&lt;li&gt;将 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-summary/blob/main/process_changes.py&#34;&gt;process_changes.py&lt;/a&gt; 添加到摘要存储库，用实际的存储库名修改 &lt;code&gt;BOOKMARK_COLLECTION_REPO_NAME&lt;/code&gt; 和 &lt;code&gt;BOOKMARK_SUMMARY_REPO_NAME&lt;/code&gt;；如果需要的话，可以调整 &lt;code&gt;summarize_text&lt;/code&gt; 和 &lt;code&gt;one_sentence_summary&lt;/code&gt; 中的 prompt&lt;/li&gt;
&lt;li&gt;回到书签存储库，将 &lt;a href=&#34;https://github.com/jerrylususu/bookmark-collection/blob/main/.github/workflows/bookmark_summary.yml&#34;&gt;bookmark_summary.yml&lt;/a&gt; 添加到 &lt;code&gt;.github/workflows/bookmark_summary.yml&lt;/code&gt;，用 &lt;code&gt;Github账号/书签存储库名&lt;/code&gt; 替换 22 行 &lt;code&gt;jerrylususu/bookmark-collection&lt;/code&gt;，用 &lt;code&gt;Github账号/摘要存储库名&lt;/code&gt; 替换 27 行 &lt;code&gt;jerrylususu/bookmark-summary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新建一个 PAT（Personal Access Token）
&lt;ul&gt;
&lt;li&gt;入口：Github 主页 - 右上角 Settings - 左侧列表底部 Developer Settings - 左侧列表 Personal Access Token / Fine-grained Tokens - 右侧 Generate New Token - 验证密码&lt;/li&gt;
&lt;li&gt;Token Name: 随便写&lt;/li&gt;
&lt;li&gt;Expiration：可以长一些，但是不能超过 1 年&lt;/li&gt;
&lt;li&gt;Repository access：选 Only select repositories，然后在下面选中自己的摘要存储库&lt;/li&gt;
&lt;li&gt;Permissions：点开 Repository Permissions，找到 Contents，选择 Read and write；其他不用动&lt;/li&gt;
&lt;li&gt;点击底部 Generate Token；Token 只会显示一次，复制下来保存好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回到书签存储库，添加密钥到环境变量
&lt;ul&gt;
&lt;li&gt;入口：书签存储库 - 顶部 Settings - 左侧 Secrets &amp;amp; Variables / Actions - Repository secrets - New Repository Secret&lt;/li&gt;
&lt;li&gt;需要添加 4 个（其实有的可以放在 Environments 里，不过这里我为了方便先全放到 Secrets 里了）；冒号前面的是名字，冒号后面的是内容&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;PAT ：第 5 步生成的 token&lt;/li&gt;
&lt;li&gt;OPENAI_API_MODEL ： 模型名，如 gpt-4o-mini；如果像我一样用 deepseek 则填写 deepseek-chat&lt;/li&gt;
&lt;li&gt;OPENAI_API_KEY ： API key，通常以 sk- 开头&lt;/li&gt;
&lt;li&gt;OPENAI_API_ENDPOINT ： 模型 API 地址，留空默认用 OpenAI 官方；可以填中转站；用 deepseek 则填写 &lt;code&gt;https://api.deepseek.com/chat/completions&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;至此应该配置完成了。可以用 osmos::memo 扩展添加一个书签试试，观察书签存储库中工作流是否正常运行，摘要存储库中是否生成了对应的摘要。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;勘误&#34;&gt;勘误&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;感谢评论区 a1032077316 指出「我也想要一节」中的部分步骤错误，已经在文中修复&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>项目</title>
      <link>https://nekonull.me/project/</link>
      <pubDate>Sat, 31 Aug 2024 23:45:30 +0800</pubDate>
      
      <guid>https://nekonull.me/project/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;我的个人项目主要都在我的 Github 上。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jerrylususu&#34;&gt;Nekonull&amp;rsquo;s Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;偶尔我会写一些小工具。为什么不去看看有没有什么能帮到你的呢？
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pages.nekonull.me/&#34;&gt;Nekonull&amp;rsquo;s Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt;历史项目&lt;/summary&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;时间&lt;/th&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;项目&lt;/th&gt;
          &lt;th&gt;链接&lt;/th&gt;
          &lt;th&gt;状态&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;2024&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;cococlock：模拟 Apple Watch 的 Gradient 表盘（JS）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;http://nekonull.me/cococlock/&#34;&gt;WebApp&lt;/a&gt; &lt;a href=&#34;https://github.com/jerrylususu/cococlock&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;✅在用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2024&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;show-bit-flag：位掩码可视化工具（JS）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;http://nekonull.me/showbitflag/&#34;&gt;WebApp&lt;/a&gt; &lt;a href=&#34;https://github.com/jerrylususu/showbitflag&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;✅在用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2024&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;day-tracker：看看今天还要工作多久（JS）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;http://nekonull.me/day-tracker/&#34;&gt;WebApp&lt;/a&gt; &lt;a href=&#34;https://github.com/jerrylususu/day-tracker&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;✅在用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;MainOnly：在网页上隐藏无关元素，只显示主体内容的小 bookmarklet （JS）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;http://nekonull.me/mainonly/&#34;&gt;Intro&lt;/a&gt; &lt;a href=&#34;https://github.com/jerrylususu/mainonly&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;✅在用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2023&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;PaddleOCR-json Java API：PaddleOCR-json 的 Java 封装（Java）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/PaddleOCR-json-java-api&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;✅在用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2022&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;航班熔断模拟器（Vue）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/rongduan_or_not&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;⛔已下线&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2022&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;Bangumi Takeout：从 Bangumi 中导出自己的标注记录（Python）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/bangumi-takeout-py&#34;&gt;Github&lt;/a&gt; &lt;a href=&#34;https://colab.research.google.com/github/jerrylususu/bangumi-takeout-py/blob/master/bangumi_takeout_colab.ipynb&#34;&gt;Colab&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🛠️仅维护&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2022&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;Gojuon Quiz：日语五十音图记忆和测试小工具（Vue）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;http://nekonull.me/50&#34;&gt;WebApp&lt;/a&gt; &lt;a href=&#34;https://github.com/jerrylususu/gojuon-quiz&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;✅在用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2022&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;Crafting Interpreter 实现和个人笔记（Java, C）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/crafting-interpreter&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2022&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;APIJSON 示例项目（Java）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/APIJSON/apijson_todo_demo&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🔄他人维护中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2021/12&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;joplin-vaccum：清理笔记 Joplin 软件中的孤立图片（Python）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/joplin-vacuum&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🛠️仅维护&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2021/12&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;队列论：事件驱动的队列模拟器（Python）&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2021/12&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;分布式系统：课程笔记，Raft/KVRaft 实现（Go）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://nekonull.me/posts/distributed-system-course-notes/&#34;&gt;博客&lt;/a&gt; &lt;a href=&#34;https://nekonull.me/distsys_notes/#/page/all%20distributed%20system%20lectures&#34;&gt;笔记&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2021/10&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;描述逻辑模拟器 ALCQ（Python）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/alcq&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2021/4&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;毕业设计：用于多媒体教学的实时字幕识别和分发系统&lt;br /&gt;语音识别 + websocket + Spring Boot&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2020/5&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;软件工程：Github Fixit&lt;br /&gt;给 Java CLI 库 Picocli 和 Java 服务器框架 Spark 修了一些 bug。&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1zK4y1x7Xz&#34;&gt;B站&lt;/a&gt; &lt;a href=&#34;https://github.com/remkop/picocli/pulls?q=is%3Apr&amp;#43;is%3Aclosed&amp;#43;author%3Ajerrylususu&#34;&gt;Github PR&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2020/2&lt;/td&gt;
          &lt;td&gt;实习&lt;/td&gt;
          &lt;td&gt;Lustre File Stat Gather&lt;br /&gt;一个扫描 Lustre 文件集群元数据得到统计信息（大小分布、日期分布等）的工具。&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/12&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;面向对象程序设计：ArchOJ：一个面向教学的在线测评系统&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/12&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;计算机安全：联创打印系统安全性研究&lt;br /&gt;调查了校内联创打印系统的安全问题，如绕过计费、登入他人账号、恢复历史打印数据等&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/12&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;计算机网络：Spanning Tree Routing&lt;br /&gt;用 Python 实现生成树路由，并用 SDN 模拟&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/CS305SDN&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/12&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;生成式新媒体设计：Processing 动画&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/ProcessingHomeworks&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/7&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;NUS Summer School: EmojiCam&lt;br /&gt;Best Project In Cluster&lt;br /&gt;openCV + 情绪识别 + FaaS 修图&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://sws.comp.nus.edu.sg/2019/WEFiles/Image/Gallery/cd06b6bd-7acf-42a2-a018-bb36aad4c5de/3004%20Emojicam-2.png&#34;&gt;Poster&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/6&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;计算机组成原理: CPU in MIPS（Verilog）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/MIPS_Single_Cycle_CPU&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;⛔不再维护&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/1&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;数字逻辑: Digital Clock（Verilog）&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/CS207_Digital_Clock&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2019/1&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;阵营九宫格生成器 &amp;amp; 逐渐离谱生成器&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://nekonull.me/9/&#34;&gt;WebApp&lt;/a&gt; &lt;a href=&#34;https://github.com/jerrylususu/9square&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;✅在用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2018/9&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;MailStat：学校邮箱邮件分析&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/mailstat&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;⛔不再维护&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2018/6&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;宿舍舍友预约系统&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;🔄他人接手运行中&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2018/5&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;Java 2: 机上娱乐系统&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/CS209A-Flight-Entertainment-System&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2018/1&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;超简单视频播放器 (Android)&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/supereasyvideoplayer&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;⛔不再维护&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2017/12&lt;/td&gt;
          &lt;td&gt;个人&lt;/td&gt;
          &lt;td&gt;某基金会捐款查询系统&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;⛔已下线&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2017/9&lt;/td&gt;
          &lt;td&gt;课程&lt;/td&gt;
          &lt;td&gt;Java 1: 答疑预约系统&lt;/td&gt;
          &lt;td&gt;非公开&lt;/td&gt;
          &lt;td&gt;🚫不适用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2017/6&lt;/td&gt;
          &lt;td&gt;&lt;div style=&#34;width:4ch&#34;&gt;个人&lt;/div&gt;&lt;/td&gt;
          &lt;td&gt;Project SFLS 🎶&lt;/td&gt;
          &lt;td&gt;&lt;a href=&#34;https://github.com/jerrylususu/projectsflsmusic&#34;&gt;Github&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;⛔不再维护&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/details&gt;
</description>
    </item>
    
    <item>
      <title>在 Devtools 里触发前端组件的内部状态更新</title>
      <link>https://nekonull.me/share/trigger-elementui-from-devtools/</link>
      <pubDate>Sat, 31 Aug 2024 22:54:10 +0800</pubDate>
      
      <guid>https://nekonull.me/share/trigger-elementui-from-devtools/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这个标题大概不太好理解；以下是对我遇到的问题，及我的解决方案的描述，在获得了相关上下文后，这个标题可能会稍微好理解一些。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;背景：在我的工作中，时常需要使用一个内部的日志查询平台。在使用时，需要先指定日志的开始和结束时间，默认情况下开始时间会被设置为今日的0点，结束时间则被设置为今日的23:59:59。虽然大部分情况下默认值都足够了，但是有时我需要调整时间范围，例如，选择为昨天，或是选择为某个 unix timestamp / yyyy-MM-dd hh-mm-ss 的前后一分钟。但无论是从界面上选择日期，还是手动输入时间都有些麻烦。我想半自动化这一过程，例如写一些 userscript 来改善时间范围的选择体验。&lt;/p&gt;
&lt;p&gt;问题：我需要在无法接触/修改前端源代码的情况下，用 js 修改这个日期选择器的值。&lt;/p&gt;
&lt;p&gt;从类名中不难发现，这个日期时间选择器底层实际上就是 &lt;a href=&#34;https://element.eleme.io/#/zh-CN/component/datetime-picker&#34;&gt;Element UI 的 DateTimePicker&lt;/a&gt;。然而如果直接修改对应的 input 的 value，并不能满足要求，因为这只修改了表现层的输出，Vue 组件中的内部状态实际上没有更新（也可以从点击查询按钮后发出的网络请求中验证）。正确的做法是用 js 在对应的元素上触发合适的事件，让组件像处理用户输入那样处理我们的请求。那应该触发怎样的事件呢？&lt;/p&gt;
&lt;p&gt;有几个思路可以找到对应的事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 Chrome Devtools 自带的 &lt;a href=&#34;https://developer.chrome.com/blog/quickly-monitor-events-from-the-console-panel-2?hl=zh-cn&#34;&gt;monitorEvents&lt;/a&gt; ：首先用右键-审查元素在 DOM 树中定位到 input，然后右键&amp;quot;存储为全局变量&amp;quot;，会保存到 &lt;code&gt;temp1&lt;/code&gt;，再在控制台输入 &lt;code&gt;monitorEvents(temp1)&lt;/code&gt; 就可以观察到该元素上的所有事件了。然后像正常使用一样操作下选择器，可以看到触发的事件和参数。（mouse 相关事件会有很多坐标更新，杂音比较大）&lt;/li&gt;
&lt;li&gt;打开 Github 找到这个组件对应的&lt;a href=&#34;https://github.com/ElemeFE/element/blob/dev/packages/date-picker/src/picker.vue#L2&#34;&gt;源码&lt;/a&gt;，相关的 &lt;code&gt;@input&lt;/code&gt; / &lt;code&gt;@change&lt;/code&gt;  等方法也能说明该组件会处理的事件类型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但作为现代开发者，首先当然还是先问问 GPT 了；GPT 给了一个看起来很靠谱的 script，节选如下。其中基本把组件可能处理的事件都触发了一次。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;click&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2024-08-31 12:34:56&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;inputEvent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Event&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;input&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbles&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;inputEvent&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;changeEvent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Event&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;change&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbles&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;changeEvent&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;blur&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 script 在官网的 demo 上的确可以用，但是很不幸在我的内部工具页面上并不行，会出现一个奇怪的 &lt;code&gt;Uncaught TypeError: Cannot read properties of undefined&lt;/code&gt; 错误，点击调用栈的话只有 minified 的代码，完全看不出来是什么问题。到这里似乎陷入了僵局。然而进一步的实验发现，似乎这个问题只会在页面首次使用的时候出现；如果我手动先选择过一次日期时间，再用这个脚本就可以设置了。看了下组件源码，注意到组件在更新内部状态时，还会同步去更新 picker（弹出的日期弹框）里的值，是否可能是这个问题？有了这个模糊的思路之后，我再次开着 devtools 开始验证我的猜想。页面首次加载之后，DOM 树中并没有 picker 对应的节点，此时用脚本设置会失败；然而手动操作时，picker 节点会被创建，设置完成后被隐藏（但依然在 DOM 树中）；再次运行脚本，设置日期时间值成功了。看来的确是 picker 在脚本运行时没有正确被初始化导致的。&lt;/p&gt;
&lt;p&gt;下一步就清晰一些了，只需要想办法在脚本操作之前，保证 picker 已经被初始化就好了；继续尝试了源码里的各种事件，最终发现可以用 &lt;code&gt;focus&lt;/code&gt; 事件触发 picker 创建，用 &lt;code&gt;Esc&lt;/code&gt; 可以让 picker 消失。（这一步其实试了很久，而且中间有几次把 &lt;code&gt;bubbles&lt;/code&gt; 写成了 &lt;code&gt;bubble&lt;/code&gt; 导致一直触发不成功）&lt;/p&gt;
&lt;p&gt;最后得到的可以正常工作的脚本如下。虽然很丑陋，但是至少能用了&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Event&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;focus&amp;#34;&lt;/span&gt;, {&lt;span style=&#34;color:#a6e22e&#34;&gt;bubbles&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;}));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;click&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2024-08-31 12:34:56&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Event&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;input&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbles&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; }));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Event&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;change&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbles&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; }));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;blur&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;inputElement&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchEvent&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;KeyboardEvent&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;keydown&amp;#34;&lt;/span&gt;, {&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Esc&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;keyCode&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bubbles&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;}));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Obsidian 与工作日志</title>
      <link>https://nekonull.me/share/obsidian-work-journal/</link>
      <pubDate>Sun, 18 Aug 2024 15:30:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/obsidian-work-journal/</guid>
      <description>&lt;p&gt;虽然从开始工作到现在已经有两年多了，但大部分时间里我需要同时跟进的事项并没有那么多，复杂度也没有太高，基本上不需要太多记录就可以完成。但是最近几个月以来，手头工作的数量和复杂度都急剧上升，完全依靠大脑跟进已经逐渐不可能了。在此背景下，我开始尝试用 Obsidian 搭建自己的工作日志系统，也读到了其他人的一些分享（如 &lt;a href=&#34;https://fev.al/posts/work-journal/&#34;&gt;Use A Work Journal To Recover Focus Faster And Clarify Your Thoughts&lt;/a&gt;）。目前我的工作日志系统已经正常运转大概三个月了，大部分坑都已经填平，也成为了我工作中不可或缺的一个部分。以下是我自己目前的一些经验，希望分享出来能帮到各位读者。&lt;/p&gt;
&lt;h2 id=&#34;工作日志能解决的问题&#34;&gt;工作日志能解决的问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在多个任务间切换而不丢失信息&lt;/strong&gt;：随着跟进任务数量的增加，将所有任务相关的信息记忆在大脑里越来越困难，然后会发现越来越多的时间被花费在信息寻找上：这个任务的代码在哪个分支上？我今天要交付的文件应该找谁要？这个项目的最新结论是上次谁在哪个群拍的板？有了工作日志之后，每个任务都有自己独立的条目，只要找到它，相关信息就能立刻获得。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;记录每一步尝试&lt;/strong&gt;：有些时候第一次尝试就能成功，但更多时候并非如此。通常需要很多次修改、调试和观察，才能确认自己是否在正确的方向上前进。最终提交的代码或文件只反映了最后成功的结果，中间的探索过程却完全丢失了。有了工作日志之后，一切中间过程都能被记录和回溯。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速复用SOP以保证关键任务的可重现性&lt;/strong&gt;：探索性的任务很有趣，但也有一部分任务是事务性的：目标明确，步骤清晰，也做过很多次了；但是步骤数量增加和操作过程的复杂度提升，都会让某一步骤遗忘/未能按照预期完成的概率增加；工作日志让维护和应用SOP（Standard Operation Procedure，标准操作流程）更简单，只要每次遵循就能避免出错。（当然更好的选择是完全将事务性工作自动化，让人不用参与，然而这并非总是可行/经济）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阶段性总结时有话可说&lt;/strong&gt;：在大厂打工，&lt;code&gt;(周|月|季|半年|年)报&lt;/code&gt;难以避免，然而很多工作都很琐碎，一个周期过去了可能发现自己甚至说不出来做了什么；工作日志让回溯历史更加简单，避免了无话可说的窘境。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;我如何使用工作日志&#34;&gt;我如何使用工作日志&lt;/h2&gt;
&lt;h3 id=&#34;什么任务需要建立工作日志&#34;&gt;什么任务需要建立工作日志&lt;/h3&gt;
&lt;p&gt;目前我的标准是预估完成时间，超过 5 分钟的任务就值得建立一条工作日志了。在我目前的工作流中，我通常会在一个 4K 分辨率的屏幕上操作，左侧 70% 是我当前的核心工作区（如浏览器/代码编辑器），右侧会开三个窗口，从上到下分别是 Apple Notes（临时任务列表）、CudaText（草稿纸/scratchpad）、Obsidian（工作日志）。当我收到一个任务（可能是电话/IM消息/当面通知）后，我会先判断该事项完成所需的时间；如果预估可以在 5 分钟内完成（简单的配置修改/信息收集表填写/告警单处理），那就会放在 Apple Notes 里作为一个新的待办项；如果预估需要 5 分钟或者更长（bug 调查/开发需求），那就在 Obsidian 里创建一个工作日志条目文件。当然预估的时间可能不准，如果实际开始做的时候发现比我预估的时间更长，我也会把这个任务从 Apple Notes 的代办项提升为一个 Obsidian 日志。&lt;/p&gt;
&lt;h3 id=&#34;工作日志模板&#34;&gt;工作日志模板&lt;/h3&gt;
&lt;p&gt;之前我是的每个工作日志都是从零开始，然而随着日志的逐渐增加，我观察到自己在每个日志初始时写下的信息有共同之处，于是从中提取建立了模板。目前我使用的模板很简单，只是有一个 Markdown 表格，描述了这个任务的常用关键信息，其中包含以下的 key：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对接人：通常是将任务分配给我的人，或者是某个项目的交付负责人&lt;/li&gt;
&lt;li&gt;群：我所在的公司使用企业微信作为 IM，通常每个项目有自己的群，其中包含了这个项目的所有参与人和关键信息；如果你所在的公司使用其他的 IM，可以替换为类似的“沟通点”概念（如 Slack 中的频道）&lt;/li&gt;
&lt;li&gt;需求链接：任务在到内部需求系统的链接，通常包含正式的需求标题&lt;/li&gt;
&lt;li&gt;MR链接：到代码库 Merge Request 的链接（提交MR后才会填写此部分）；主要用于回溯时快速找到相关的代码变更&lt;/li&gt;
&lt;li&gt;其他链接：其他和此任务相关的链接，例如在线文档、内部的 Wiki 页面、配置系统地址&lt;/li&gt;
&lt;li&gt;预期交付时间：该任务的预计完成时间，用于决定优先级&lt;/li&gt;
&lt;li&gt;共识/结论：一个任务可能会跨越较长的时间，而其中结论可能时刻变更。我通常在这个字段中以时间倒叙记录最新结论（日期-人-结论）&lt;/li&gt;
&lt;li&gt;代码分支：如果这是个开发任务，相关的代码变更在哪个分支上&lt;/li&gt;
&lt;li&gt;涉及模块：如果这是个开发任务，需要开发/测试/部署的模块列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用工作日志&#34;&gt;使用工作日志&lt;/h3&gt;
&lt;p&gt;从模板建立工作日志并填充基本信息后，这个工作日志就可以使用了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不限定记录内容：对于工作日志中记录的内容，我并没有做限定，而是基本想到什么/用到什么/看到什么都会记录进去，例如调试时的 trace id，自己的猜想和验证结果，模块/方法的调用链，可以参考的代码段，群聊中重要信息等等。&lt;/li&gt;
&lt;li&gt;自己QA：另一个常见的做法是自己给自己提问，通常是写下一连串问题（Q：为什么这个bug在case1的情况下不会触发？），然后通过一系列探索填充答案（A：因为外部的检查提前失败报错了）（基本上把自己当作一个 LLM 来用）&lt;/li&gt;
&lt;li&gt;每天分割：对于一个持续时间较长的任务，工作日志可能也会变得逐渐混乱起来；我自己的做法是用 &lt;code&gt;---&lt;/code&gt; 分割每天的记录，并在开头标记日期。&lt;/li&gt;
&lt;li&gt;从 SOP 复制：如果这是个事务性任务，而且此前已经有 SOP，则可以直接复制 SOP（例如 checklist），以便完整并正确地重新完成任务。（注意：最好不要直接从历史日志复制，一来这揭示了你可能需要一个SOP，那就应该去正式建立一个；二来历史日志中可能存在干扰细节，例如需要每次生成的ID，直接复制可能让你出错）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;特殊文件&#34;&gt;特殊文件&lt;/h3&gt;
&lt;p&gt;除了每个任务特定的日志之外，我还维护了一些特殊文件，每个都有自己的特定用途。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOPs：当我发现我在重复历史任务时，就会提取出一个SOP，其中是整理过可以直接复制到新日志中的内容；通常包含任务描述，前置条件，步骤的checklist、每个步骤需要的信息（如配置系统链接）&lt;/li&gt;
&lt;li&gt;weekly：用于组会的事项列表。我所在的小组的组会是周五下午；通常我会在周五上午填写本周已完成的事项，以及下一周将要启动的事项，这样组会上就不用临时寻找了。&lt;/li&gt;
&lt;li&gt;lowlights：可改进的项目集合。通常会在遇到一个让我不爽的事情（如某个内部工具不好用）时快速记录，组会前再填写到专用的复盘文档。&lt;/li&gt;
&lt;li&gt;hacks：用来记录一些偶尔遇到但是每次想不起来怎么做的事情的操作说明。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;相关的-obsidian-插件&#34;&gt;相关的 Obsidian 插件&lt;/h3&gt;
&lt;p&gt;虽然工作日志的存在本身就是有意义的，但是和一些 Obsidian 插件配合可以更方便。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tasks：一个 Obsidian 体系下很强大的任务管理插件。我一般的用法比较简单，每个工作日志开头会有一个 Markdown TODO 项目（&lt;code&gt;- [ ]&lt;/code&gt;开头），Tasks 插件会将所有这类任务收集起来，呈现在一个统一的视图中；这样我只需要看这个视图，就能定位到还有哪些未完成的任务，并快速跳转到相关的笔记了&lt;/li&gt;
&lt;li&gt;Unique Note Creator（时间戳笔记生成器）：在侧边栏添加一个按钮，点击时套用模板，创建一个带有当前时间戳的新笔记。目前我创建工作日志的主要方式。&lt;/li&gt;
&lt;li&gt;Another Quick Switcher：在快速切换选择器中，让搜索结果以修改时间逆序排列（原生的 Quick Switch 并非如此），避免切换到非预期的很久之前的笔记中&lt;/li&gt;
&lt;li&gt;Scroll To Top：在笔记右下角增加按钮，可以快速跳转到笔记开头或者结尾；对于很长的笔记比较有用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;暂未解决的问题&#34;&gt;暂未解决的问题&lt;/h2&gt;
&lt;p&gt;最后是一些我目前还没有完全解决的问题，如果有思路欢迎分享。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;粘贴长代码时折叠不便：虽然 Obsidian 有自带的折叠机制，但是用在代码上总感觉不太方便；用于列表/标题的 Folding 会导致文件增加不需要的结构；Callout 因为属于引用，粘贴代码的时候需要一些特殊处理才能让代码段正确放进去。希望能找到一个更接近 Github Markdown 预览中类似于 &lt;code&gt;&amp;lt;summary&amp;gt;&lt;/code&gt; 的方案。&lt;/li&gt;
&lt;li&gt;切换到其他文件时丢失阅读进度：如果关闭了某个笔记 tab，下次重新打开的时候，默认会回到文件开头而不是上次阅读/编辑的位置。尝试了几个社区插件但是效果不佳。&lt;/li&gt;
&lt;li&gt;命名问题：同一个任务可能有多种描述，然而如果关键字不在标题里就搜不到；现在我的做法是把任务所有的关键字都扔在标题里（类似于 SEO），虽然看起来不太美观但是搜起来很好用。一个改进方向可能是自定义搜索，让某个关键词可以匹配多个同义的关键词？&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>读书记录《时间贫困》</title>
      <link>https://nekonull.me/share/book-time-poverty/</link>
      <pubDate>Mon, 12 Aug 2024 21:36:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/book-time-poverty/</guid>
      <description>&lt;p&gt;书名：《时间贫困》&lt;/p&gt;
&lt;p&gt;评价：7/10；很短的书，快的话一小时就能读完；了解到了一些和自己认知之外但符合自己真实感受的观点（e.g. 完全躺平未必会快乐）；可能会试试书中描述的行动。&lt;/p&gt;
&lt;p&gt;版本：微信读书&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;观点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可支配时间长!=幸福&lt;/strong&gt;：可支配时间太少（如每天少于2小时）会带来压力，从而降低幸福感；可支配时间太多（如每天超过5小时）会让人缺乏目标感，从而降低幸福感；排除时间太少和太多的极端情况，幸福与你所拥有的可支配时间的长短无关，而是取决于你如何利用自己拥有的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间充裕与否会影响自信&lt;/strong&gt;： 时间很多时，我们倾向于积极聚焦。时间充裕总体上会提升我们的信心，让我们对有信心实现的一切感到乐观而兴奋。只要有足够的时间，我们将前途无量。但在时间有限时（现实往往如此）​，我们就会悲观地倾向于预防聚焦。当所剩时间不多时，我们满脑子都是失败的可能性，从而会降低目标来匹配不足的信心。深陷时间贫困时，我们只是在勉强度日。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更自信的人认为自己也拥有更多时间&lt;/strong&gt;：当人们感受到更强的自我效能感时，他们也会认为自己拥有更多时间。这一发现意义重大，因为它意味着你可以有意识且有效地操纵你的时间宽裕度。通过采取一些手段增强你的自信心，你就会大大缓解时间贫困的困境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快乐不意味着远离工作&lt;/strong&gt;：快乐并不意味着要远离工作，因为（正如我们所知）工作是有意义的。关键在于，对时间的思考会促使我们把时间花在那些能带来个人成就感的活动上。我在那些认为工作有意义的人中重新进行了第一项研究，结果证明对时间的思考激励着他们在工作中做得更多。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;亲密关系是快乐的必要条件&lt;/strong&gt;：这一重要的数据表明，尽管没有一个变量是快乐的充分条件，但亲密关系是快乐的必要条件。换句话说，有朋友并不能百分之百保证你会快乐，但要想变得快乐，你需要朋友。 只有当我们有了归属感（爱与被爱）​，追求个人成就和自我实现所付出的个人努力才是值得的。如果你想攀登事业的阶梯，这很好，但前提是不要为此牺牲你与生活中所有人的联系。如果你到达顶峰时没有人和你一起庆祝，那么你也不会有多大的成就感。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;花钱买时间可能是有意义的&lt;/strong&gt;：有研究确实警示我们，与购买更好的体验相比，购买物品带来的快乐感明显更少且不持久。此外，阿什利团队的分析结果表明，外包家务带来的积极影响并不取决于收入水平。花钱买时间可以使大多数人受益。无论你有多少钱，时间对每个人来说都一样宝贵。 如果你花点儿钱来给自己腾出一些时间，你就可以用这些时间去做对你来说真正重要的事情了。你可以更有效地使用买来的时间，把它们花在那些更快乐、更有意义的活动上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;户外让人更快乐&lt;/strong&gt;：有无数个例子证明：人们在户外更快乐。此外，这种快乐程度的提升并不取决于天气（尽管人们在阳光明媚的温暖天气中的确更快乐）​、他们正在做的事（尽管有些特别快乐的活动只能在户外进行，如打理花园或赏鸟）或环境（尽管人们在大自然或绿色空间中比在城市更快乐）​，而是只需要到户外即可&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;价值观+优势+爱好=更满意的工作时间&lt;/strong&gt;：越来越多的证据表明，即使你从事的工作并不完美（实际上，没有一份工作是完美的）​，但如果你将工作同你的价值观（你在意的事物）​、你的优势（你擅长的事物）以及你的爱好（你喜欢的事物）结合起来，你就会更有动力，在工作上也会表现得更加出色，对工作和生活的总体满意度也会提高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作场所也能交朋友&lt;/strong&gt;：如果你在工作时间内开展一些真实的人际交往活动，你的工作时间会变得更快乐、更有意义。花时间在工作中结交朋友是值得的。我们清醒的大部分时间都在办公室度过，如果把这些时间都花在痛苦的工作上，那就是一种浪费。你必须摒弃这样一种观念：在工作场合中不能展现出真实的自我。 如果办公室有个你想见的人，那么你就会有上班的动力，这个人也会帮助你在工作时间获得更多的快乐和成就感。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同年龄对平凡快乐的感知不同&lt;/strong&gt;：对年轻人来说，不平凡的经历比平凡的经历更让他们感到快乐；而对年长者来说，平凡的经历给他们带来的快乐不亚于不平凡的经历。换句话说，从统计学上来看，年长者从平凡的经历和不平凡的经历中获得的快乐几乎一样多。 随着年龄的增长，人们从平凡的经历中获得的快乐会越来越多，自然而然也会意识到自己所剩的生命是有限的。当人们意识到自己的时间宝贵时，就会更享受简单时刻的快乐。这些结果表明，尽管我比阿米特大不了多少，但我正在迈向人生的下一个阶段。这也就解释了我和阿米特的快乐周末为何不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快乐时间是有限的&lt;/strong&gt;：一旦你认识到剩下的时间是有限的，你在这段时间里会更快乐。虽然在注意到时间如此有限后，你可能会感到不安，但你会更加关注并更容易发现那些简单的快乐。认识到“快乐的时光是短暂的”不仅有助于你度过艰难时期，还会提醒你停下脚步，这样你就不会错过一路上的美好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应该优先考虑带给你快乐的事&lt;/strong&gt;：研究者阿纳·凯南和拉恩·基维茨也观察到这个现象。他们巧妙地称其为“远视现象”​，即一种过于有远见的、只选未来不顾现在的倾向。这是过度自控的问题。他们指出，把苹果当零食确实比巧克力蛋糕更健康，但倘若每次都选苹果，你就永远尝不到美味的巧克力了。如果总是选择“该做之事”而非“想做之事”​，你就永远不会有享受的机会。年复一年，你只干正事，但回首往事时，你可能会因为错过了生活中应有的快乐而感到非常遗憾，比如白亚麻餐布上的羊角面包。  所以，在有限的时间里，确定、承诺并优先安排能带给你快乐的活动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆分喜欢的活动以避免享乐适应&lt;/strong&gt;：随着时间的推移，我们会习惯现有事物，所以我们在一项活动开始时会特别敏感。这是我们最专注的时候，体验也最为强烈。因此，为了利用享乐适应，你应该把你喜欢的活动拆分开——创造更多开始，防止厌倦滋生。美好事物的延续也会带给你更多期待。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行动&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间追踪&lt;/strong&gt;：记录自己的时间分配和快乐程度，找出快乐和不快乐的活动中存在的共同点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算剩余时间&lt;/strong&gt;：计算一下涉及其他人的活动中，将来可能做这项活动的大概次数，也就是他们还剩下多少次机会，以及现在已经用尽了多少比例的机会&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每周留出独处和思考的一小时&lt;/strong&gt;：舒式一小时比起之前提过的消除干扰所带来的快乐更有意义。正是在这样一段时间里，你可以更深入地处理问题、更恣意地创新、更有效地制定战略，以应对需要关注的重要决策&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>惠州海边躺平记录</title>
      <link>https://nekonull.me/archive/2408-huizhou-layflat/</link>
      <pubDate>Mon, 12 Aug 2024 17:08:00 +0800</pubDate>
      
      <guid>https://nekonull.me/archive/2408-huizhou-layflat/</guid>
      <description>&lt;p&gt;基本信息&lt;/p&gt;
&lt;p&gt;日期：2024/8/10 ~ 2024/8/12&lt;/p&gt;
&lt;p&gt;原因：因为年假快到期了，想着赶快花掉；之前在网上看到过惠州躺平的视频，于是也想来试试&lt;/p&gt;
&lt;p&gt;地区选择：看了下小红书的帖子，主要推荐的是泡泡海这一边，另外似乎还有几个海边的点，但是都属于旅游区，价格和生活基建上会贵一些；然后在美团找了，的确有做相关民宿的，价格大概是200/晚；最后选了一家在 海悦长滩花园 的，宣传是阳台可以看到一线海景&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第一天下午更新&lt;/p&gt;
&lt;p&gt;前往：8/10 上午出发，高铁大概半个小时就能到（24元，深圳北-惠阳）；但是到了之后还要再打车，高铁站打车过来大概是 50 元（比高铁票还贵一些了）；开到附近的时候可以很明显附近除了几个大的看海小区，剩下的都是城中村和农民房，还是有一些生活气息的；下车后找到进楼的入口花了点时间，4部电梯 + 31层，需要稍微等一下，但是也还可以接受；等电梯的时候看了下，住户应该都是暑假或者周末出来玩的，不像是长期住户；到了之后直接电子门锁密码开门就行&lt;/p&gt;
&lt;p&gt;房间：很简单的一房，有卫生间，床，阳台，沙发；阳台上的确是一线海景，因为楼层足够高，虽然附近有其他楼遮挡，还是可以看到很多大海；不过可能是之前的期待值太高，第一眼看起来并没有预想的那么震撼（后来待久一些，其实还是挺耐看的）；缺点是楼下在挖路，机械的声音比较嘈杂；房间内部就是类似酒店的陈设，没有什么特别好介绍的；热水器是即热式的，不过一开始进来的时候跳闸了，和房东联系了之后才找到开关打开。；在阳台上望出去还能看到远处的港口和工业园区，看大烟囱喷白烟也挺奇妙的。；另外还有个缺点是阳台可以看到附近的入户走廊（那也就意味着入户走廊上也能看到你），所以不是完全的隐私的阳台&lt;/p&gt;
&lt;p&gt;海滩：在房间里稍微休整了一下，然后决定下楼去海滩看看；大概一两百米就能走到海滩入口；上一次去海滩感觉已经是很久之前的事情了（硬要说的话应该是本科某次班级活动，在海边租了别墅轰趴），下海游泳就更久了（初中？），虽然去深圳湾公园倒是去的很多（上一次应该是在24年3月）；这次没有带泳衣，也不打算游泳，只是在海边沙滩上走走感受一下就足够了。海水漫过脚尖，然后再慢慢流回去，有种说不出来的舒适和放松感；海浪的声音也很有规律。附近的海滩还挺长的，感觉上可能大概有五六百米（后来地图看了下，大概是八百多米），第一段是普通的海滩，没有防鲨网但依然有人尝试下海泡着（然后被救生员骂回岸上了）；然后是一段游船和摩托艇用的海滩，还有一些浮桥作为码头；再往后是可以下海的海滩，人很多，有种泡饺子的感觉（但是肯定没有大梅沙那么多人）；再往后是一段人少的海滩，能真正感受到沙子的细腻，更类似于影视作品中细沙的感受（前面的海滩感觉有很多碎而尖的东西，不确定是贝壳还是啥，有点磨脚；另外还有烧烤竹签啥的，得时刻注意脚下）；走到头是个叫虎洲岛的小岛（其实和陆地还是连起来的），用铁丝网封起来，还有告示牌说不能进入，但是依然有人挖了洞钻进去（里面还不少人）；走到头之后就慢慢往回走，偶尔就干脆停下来让腿感受海浪的冲刷；后来来了几波大浪，短裤也彻底湿了，就开始慢慢走回去；前半段的时候天气还有点阴沉，但后面偶尔出了点太阳，能看到阳光把浪花高亮起来；总之是一次很舒服的体验&lt;/p&gt;
&lt;p&gt;周边：楼下有好几家便利店，稍微走了下也有不少快餐，不过物价比深圳的城中村稍贵（可乐 4.5，快餐 20~25），长期居住的话吃饭的开销可能比较严峻；外卖基本也能完全 cover，价格也就是一般城区外卖的价格；旅游区当然还有不少海鲜餐馆，不过这次海鲜不是重点就先跳过了；另外靠近海滩还有不少推车小贩，没问价格，但是至少吃的选择上肯定是够多了&lt;/p&gt;
&lt;p&gt;房租：楼下有托管中心，尝试问了下，大概是每月一千的价格，年租价格相同（长期躺平的话房子价格有些贵了，相比于其他四五百一个月的地点来说），但是海景和层高是个很大的优势&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第一天晚上更新&lt;/p&gt;
&lt;p&gt;夕阳西下的时候，决定还是去附近走一走，顺带想想晚饭去哪里吃；下楼之后大概转了下，走到镇上去又走回来，一路上基本都是海鲜餐馆，而且都是大份量的饭菜，面向的都是两人或者以上的，一个人吃的话其实很难找到比较好的选择（例如看了几家餐馆的菜单，海胆炒饭起步70+，一般的蛋炒饭也要三四十）；一个人吃的话，基本上要么是海滩附近的推车小贩，要么就是类似于兰州牛肉面、沙县小吃这类各处都能吃到的食物了；最后还是选择在海滩附近的推车小贩搞了点吃的：蛋炒饭20（还不错，虽然已经要求了微辣，但是对我来说辣椒还是放多了）；蚝烙15（感觉和之前听说的不太一样，实际感受是生蚝没放多少，倒主要是面饼了，感觉不是很值）；还在附近的摊位买了烤肠x3 10元（纯淀粉肠，而且里面感觉没热透；吃了两个，剩下一个放弃了）；考虑明天以外卖为主吧，或者就楼下随便吃点；另外回公寓的时候发现楼下的两家便利店，可乐的价格相差一块钱（5元vs4元），买东西的时候还是得小心点；最后买了水、可乐和明早的面包，就回房间了，晚上还是走了不少的，少说得有两公里了（回来查了下地图是2.2公里），附近也就是正常县城的基建水平，长期定居的话也不是不能接受。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第二天上午更新&lt;/p&gt;
&lt;p&gt;晚上睡觉的时候发现了一些小问题；一是外面走廊的灯太亮了（之前也提过阳台可以看到外面走廊），必须要拉窗帘才能睡得着；二是房间的隔音不是非常好，虽然可能隔壁房间没有住客所以没有什么声音，但是外面走廊的声音（例如行李箱滚轮）可以听的很清楚；三是早上的时候楼下工地的声音比较大，会被吵醒（看了下是七点多），未来如果还要来的话得考虑带上耳塞；四是床附近没有插座，所以只能先把手机的电量充满再放到床边用，不是很方便；五是晾衣服的地方不太够，目前暂且是挂在椅子和桌子上晾的；六是因为角度的问题，需要呆在阳台的一个死角，才能不被对面走廊看到。&lt;/p&gt;
&lt;p&gt;昨晚大概是两点多睡的（应该是晚上喝了可乐的缘故，咖啡因太强睡不着）；七点多醒了一次，最后实际起床是十一点左右。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第二天下午更新&lt;/p&gt;
&lt;p&gt;在房间里摸了一会到了十二点多，远处的天空渐渐阴沉了，也能不断听到滚滚雷声，但是就是没有雨；过了会到十二点半，倒是有些小雨，能从阳台玻璃上看到雨滴，然而感觉并不算大；看了下手机大概十分钟后就停了（虽然惠阳气象台发了预警，但是估计主要是城区，海边影响比较小？）；快一点多决定还是下楼去搞点吃的；下了楼，决定在昨天看到的沙县吃个午饭，就点了比较简单的鸡蛋火腿炒米粉 18元；上的倒是很快，也就是一般水平，油多了点（连吃两顿炒粉还是不太能顶得住）&lt;/p&gt;
&lt;p&gt;吃完了决定再去海滩转转。这次一开始在海边走反而不太适应了，明显感觉有点扎脚，怀疑是类似于塑料碎片之类的东西，没有被充分打磨过，走了一段反而有种上刑的感觉了；再往前稍微走了一点到靠近游船码头的地方，沙子的感觉才明显好起来，更接近期望中的顺滑的细沙的感觉；再往前走，景象和昨天没什么差异，船还是那些船，人也是一样的多（甚至感觉比昨天更多了，不知道是否错觉）；不过摩托艇似乎降价了（昨天六七十2个人，今天只要五十了，可能是因为七夕的缘故？）；在沙滩上站了一会，感觉越来越晒了，才发现乌云早就飘走了，烈日重新照耀起来；在往回走的时候，突然想下海试试看；因为是中午，海水并不会感觉很凉，甚至还有些微微的暖意；不敢走的太远，就在可以站着碰到底部的地方，让身体随着海浪慢慢漂浮；体感上其实和之前在海边的感受没有什么不同，只是一个人的话可能会感觉更自由一些？；虽然想放松下来，不过想到自己一来不会游泳且没有游泳圈，二来衣服还在沙滩上没人看着，所以其实没法完全放松；泡了几分钟，感觉也体验的差不多了，就决定回去了。&lt;/p&gt;
&lt;p&gt;快回到楼下时，在便利店买了点水、吃的和雪糕，居然花了25元，果然是景区价格；回到房间有空调的确是太爽了，赶快把衣服脱了开始洗澡，再把衣服也泡了水，尝试把衣服上沾到的沙粒洗干净，然而发现水下去之后盆底还是有一层薄薄的沙，估计临时处理下还是冲不干净的，得回家再做处理；阳台上已经完全放晴了，不过这会外面还是太热了，决定把阳台上的椅子搬到屋里，边望着海景边打字（还开着空调），实在是舒服；海面上能看到游船和摩托艇，不过我是没什么兴趣就是了，下次有机会的话再来体验吧。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第二天晚上更新&lt;/p&gt;
&lt;p&gt;落日时分决定把电脑搬到阳台上，边看着夕阳边刷着视频和网页，感觉也十分宁静；落日下去之后已经是七点多了，决定去找点东西吃；之前美团上看到了楼下有烧烤，于是决定去试试；点了正常的一人份（鸡蛋炒方便面13 牛肉串x2 10 羊肉串x3 10 韭菜x1 3 金针菇x1 3），价格39元，也是一般正常烧烤的价格，味道的话还可以；吃完了回去海滩旁边看了下，原来晚上海滩上也是有人的（不过海滩上的灯不是很亮，感觉上不是很安全）；附近买了根烤肠5元，又在楼下便利店买了水，就准备回房间了；没有什么特别值得记录的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第三天上午更新&lt;/p&gt;
&lt;p&gt;今天睡得比昨天好一些；7点多醒了一次，把窗帘拉开了（不过实际上从床头的位置看不到什么海景，还是得站起来才能看到）；然后又继续睡了；10点左右一阵雷声彻底惊醒了，赶快起来先把衣服收掉了，这时雨云还在远处，昨天可以看到的远处工业基地已经看不到了；收完衣服雨也接近了，小镇都看不太真切，整片天空都被染成了朦胧的均匀的灰色；虽然天气预报写的是大雨，不过实际在阳台上，有屋檐的遮挡，实际上感觉会类似于细雨；海上依然有船，摩托艇倒是全都消失了；决定把电脑搬到阳台上，边听雨边刷刷新闻；后来发现闪电越来越接近，决定还是转移到屋内了&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第三天中午更新（等车时）&lt;/p&gt;
&lt;p&gt;快走的时候才发现原来定的是下午1:48的车，然而退房时间是12点，从海边到高铁站的车程大概40分钟，所以得在高铁站等大概一个小时；试图看了下有没有可能改签到更早的班次，然而都已经售罄了，遂放弃，反正早到了多等等也没啥问题，别赶不上就好；收拾了下东西之后，重新检查了一次所有东西都带走了，就退房了；然后才发现保洁一直在外面等着（11点半的时候就来敲过一次门了）；然后就是下楼打车，高德等了几分钟没打到，换了滴滴才打到（可能提前预定的话会更方便一些）；车开过来大概八分钟，到高铁站的时候差不多12:55；本次的高铁居然前面晚点了几分钟，估计出发也要晚点了（13:45-&amp;gt;13:52）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;结论&lt;/p&gt;
&lt;p&gt;评价：7.5/10&lt;/p&gt;
&lt;p&gt;总体上来说还是一次挺满意的旅行，完全实现了之前定下的放松+看海的目的。房间虽然不大，但是也干净够用，阳台上也的确能看海。中间还去沙滩上走了两次，还去海里泡了下。吃的也还行，以旅游价格来说的话，也吃了烧烤和蚝烙。（很多店铺都是以家庭或者团体为单位来定菜单的，没有太多一人吃的店）。&lt;/p&gt;
&lt;p&gt;然而对躺平长居来说的话，可能不是一个太好的备选；在阳台上看海虽然很棒，但是主要也是在前面几天，后面很快就会腻了；房间比较小，也没有什么事情做，基本上也就是上网和刷视频，完全提不起兴趣做任何“有用“的事情（不过可能想要做有用的事情就已经不是长居躺平了）；房价对躺平来说稍微有些贵了（约1k/月），主要的溢价应该都在海景上了，距离火车站也比较远，内陆城市相同价格应该能找到更靠近市区/交通枢纽的躺平地点。&lt;/p&gt;
&lt;p&gt;另外本次的体验也让我暂时明白了一点，目前的自己估计还是处于”卷也卷不动，躺也躺不平“的状态。虽然这个周末自己的经历，已经几乎完全接近理想中的躺平了，但是感觉上也就前一两天能够享受，后面有一种饱和（或者说电已经充满了）的感）；对我来说偶尔来充充电还是可以的，但是完全放松下来什么都不做，感觉还是缺了点什么；可能是我目前还没有找到合适的打发时间的方式？不知道呢，人总是这样自相矛盾的生物。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开销总计 766 元，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;民宿：440（2天）&lt;/li&gt;
&lt;li&gt;交通：来回高铁 25x2 + 来回打车 50x2 = 150&lt;/li&gt;
&lt;li&gt;饮食：第一天晚饭 45 + 第二天午饭 18 + 第二天晚饭 44 = 107&lt;/li&gt;
&lt;li&gt;其他：便利店 69&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>工作两年了</title>
      <link>https://nekonull.me/posts/2-years-of-work/</link>
      <pubDate>Sun, 04 Aug 2024 09:11:00 +0800</pubDate>
      
      <guid>https://nekonull.me/posts/2-years-of-work/</guid>
      <description>&lt;p&gt;从我 22 年 8 月开始参加工作以来，已经过去了两年的时间。我自己也马上就要 25 岁了。决定还是写点什么东西记录一下。本文可能没有什么结构，只是想到什么写什么；另外出于众所周知的原因，无法详细描述具体细节；还请各位读者见谅。&lt;/p&gt;
&lt;p&gt;总体感受：7/10&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作稳定性
&lt;ul&gt;
&lt;li&gt;虽然目前看还算稳定，但是因为个人强烈的风险厌恶偏好，自己依然以”明天可能就会失业“的态度进行财务规划；体现为对长期大额负债（如房贷）的拒绝，和对现金流、资金灵活性的强烈偏好（如货币基金占比较高）&lt;/li&gt;
&lt;li&gt;任何时候离失业只差一次重大事故；至今的工作生涯中已经第一次出现了产生资金损失的事故，虽然不是自己直接造成的，但是也有一些自己的间接原因&lt;/li&gt;
&lt;li&gt;自己对事故的态度比较悲观：事故总会（eventually）发生，只是或早或晚的问题；我所能做的，只是尽我的能力尽量推迟其发生，或是减少影响程度罢了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作内容
&lt;ul&gt;
&lt;li&gt;主要是 keep the lights on
&lt;ul&gt;
&lt;li&gt;日常处理一些杂活，参考和优化现有的 SOP&lt;/li&gt;
&lt;li&gt;作为团队对外的 point of presence，接收其他团队的咨询，如果处理不了就拉更高级别的同事上升&lt;/li&gt;
&lt;li&gt;减缓团队内其他更高级别工程师的压力，分担事务性或者紧急但是技术上不复杂的工作&lt;/li&gt;
&lt;li&gt;也作为一些小项目的交付负责人，主要是一两个月内就能交付的短期项目（我认为自己当前的规划和沟通能力也不足以支撑更大的项目）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全栈：cpp 内部服务、vue2/typescript 内部CRUD站点、python/sql 数据任务和数据分析
&lt;ul&gt;
&lt;li&gt;虽然说是cpp，但是其实基本不太会用高级特性，大部分事情rpc框架就处理了，更像是go/java写业务需求的感觉；对底层的了解不够深入&lt;/li&gt;
&lt;li&gt;一个人完全负责某个特定模块，的确能极大降低沟通成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作体验
&lt;ul&gt;
&lt;li&gt;目前进入一个比较顺利的状态，日常的工作大部分在舒适区内，小部分有挑战性
&lt;ul&gt;
&lt;li&gt;已经建立了对组内负责系统的心理模型 mental model，例如能大概说出请求从进入到返回，会经过哪些模块（类似于原来是RAG，现在是直接fine tune了）&lt;/li&gt;
&lt;li&gt;对部门、公司的基础组件、框架有了一定了解和使用经验&lt;/li&gt;
&lt;li&gt;被认可作为团队战力的一部分；但是有些事情目前只有自己在完全负责，虽然有理论上的备份负责人然而没有切换过，有些担忧&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;团队关系正常
&lt;ul&gt;
&lt;li&gt;日常工作交流都很正常（虽然自己不会和同事一起吃饭）&lt;/li&gt;
&lt;li&gt;ld人比较好，会批临时请假，但是感觉压迫感有些强，有的时候性急会上压力（不过可能能做到这里的管理者都是如此？）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本做到工作生活平衡和分离
&lt;ul&gt;
&lt;li&gt;工作时间 10am - 8pm，除去午休和晚餐，纯工作时间基本有 8h；然而通勤比较远，实际出门和到家的时间是 8-9；但至少可以保证双休，已经比很多中小厂好了&lt;/li&gt;
&lt;li&gt;周末基本不处理公司事务，紧急事情电话通知；目前还没有周末物理去公司加班过（虽然偶尔要从家里远程加班），期望可以继续保持不加班&lt;/li&gt;
&lt;li&gt;天气适合时（not 冬季）的中午保持运动&lt;/li&gt;
&lt;li&gt;之前有些架构变动，被调去支援其他数据系统，半夜 oncall 十分难受，人真的会崩溃，好在后面出来了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开发者体验 devex 尚可，但还有改进空间
&lt;ul&gt;
&lt;li&gt;有基本的 CI；业务重要所以没法 CD，但是发布频率足够高&lt;/li&gt;
&lt;li&gt;治理任务分配系统很有用（虽然作为处理人也很烦人）&lt;/li&gt;
&lt;li&gt;单元测试应该更多（现在感觉不太够，至少有些重要的点的覆盖率我自认为肯定是不够的）&lt;/li&gt;
&lt;li&gt;UAT测试有但是用处存疑&lt;/li&gt;
&lt;li&gt;监控系统还不错而且一直在改进&lt;/li&gt;
&lt;li&gt;LLM 用于开发和代码评审&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;职业发展
&lt;ul&gt;
&lt;li&gt;升职顺利
&lt;ul&gt;
&lt;li&gt;从入职到现在还算顺利，每个可以升级的节点都升级了&lt;/li&gt;
&lt;li&gt;最近的一次升级感觉有些得不配位，另一位和我同期进来的同事，我认为做的比我更好（甚至周末还来加班）&lt;/li&gt;
&lt;li&gt;感觉更高职级的更惨：压力大、开会很多、周末还要加班处理事情（还有晚餐后和家里的小孩视频电话，听起来就很&amp;hellip;）；现在的职级反而比较舒服，会也比较少，可以安心写代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绩效和薪资还算满意
&lt;ul&gt;
&lt;li&gt;去年拿了一次好绩效&lt;/li&gt;
&lt;li&gt;入职的时候 base 比另一个 offer 低很多，且房补在跳槽时很多公司不认可；好在最近薪酬改革后房补融入了 base，且职级提升也对薪资有影响，总算是比 2 年前的另一个 offer 的 base 高了&lt;/li&gt;
&lt;li&gt;年终奖不是在当年发放完，而是拆到多年发放，有些坑（算是把你拴在这里了）&lt;/li&gt;
&lt;li&gt;既然现在还不错，能撑多久算多久吧（Enjoy it while it lasts）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跳槽前景不佳
&lt;ul&gt;
&lt;li&gt;基本上都在写业务逻辑，疏忽了对框架底层和技术的投入&lt;/li&gt;
&lt;li&gt;虽然考下了软考高级系统架构设计师证书，但是在私企的用处不大&lt;/li&gt;
&lt;li&gt;目前的业务已经是国内头部了，未来要跳的话如果同一方向则可选非常少&lt;/li&gt;
&lt;li&gt;希望能看看大模型相关的机会，但是知识缺失 gap 太多了，不知道从哪里补起来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>软考高级架构师备考记录</title>
      <link>https://nekonull.me/posts/ruankao-architect/</link>
      <pubDate>Sun, 04 Aug 2024 09:07:00 +0800</pubDate>
      
      <guid>https://nekonull.me/posts/ruankao-architect/</guid>
      <description>&lt;p&gt;我参加了 2024 年上半年（5 月）的软考（全称：全国计算机技术与软件专业技术资格（水平）考试），通过了高级资格「系统架构设计师」的考试。本文记录我的备考过程。&lt;/p&gt;
&lt;h2 id=&#34;个人背景&#34;&gt;个人背景&lt;/h2&gt;
&lt;p&gt;科班 CS 本科，参加工作 2 年，大厂底端程序员。&lt;/p&gt;
&lt;h2 id=&#34;参加软考的原因&#34;&gt;参加软考的原因&lt;/h2&gt;
&lt;p&gt;如果回看我的 &lt;a href=&#34;https://nekonull.me/posts/end-of-2023/&#34;&gt;23年总结&amp;amp;24年展望&lt;/a&gt; 的话，会发现当时我已经把通过软考作为 24 年的个人目标之一了。其实我接触软考是 23 年 9 月，但是了解信息有些延迟，当时已经过了报名窗口，所以只能再等半年。当时我并没有非常清晰的动机，以下列出的原因只是站在考完的时间节点上反向硬找出来的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学生时代的考试思想延续：作为中国学生，考试思维估计是我思想中比较难剥离干净的一部分了，核心是将各类难以量化的目标想方设法量化，并且制定明确的验收标准（例如通过考试）来催促自己达成目标&lt;/li&gt;
&lt;li&gt;学习架构设计：虽然我接受了科班教学，也做过不少项目（无论是学生时代还是工作之后），但是大部分情况下，架构要么是直接给出（例如更高级的同事已经设计好了），要么是自己瞎整（例如各类课程项目），没有系统性学习过；既然刚好有”系统架构设计师“这个资格科目，作为考试也有系统性的知识梳理，不妨以考促学&lt;/li&gt;
&lt;li&gt;为未来发展留点余地：虽然目前在私企工作用不上，但是未来无论是跳槽国企还是润其他国家，软考的证书认可度还是可以的（e.g. 软考在日本永居打分接受的证书列表中）&lt;/li&gt;
&lt;li&gt;退税：考过了的话可以&lt;del&gt;退税 3600 元&lt;/del&gt; （8/7 评论指正：是 3600 元的退税额度，实际退税金额取决于税率）（每个税收年度可以在继续教育类目下认证一个资格类证书）&lt;/li&gt;
&lt;li&gt;听起来比较厉害：毕竟叫做高级，能满足下虚荣心
当然每个人可能还有其他的原因（例如落户、国企内评职称、所在地域有优惠政策&amp;hellip;），不过我自己的原因大致就是以上这些了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但决定参加前，也必须要了解软考的局限性：软考本质上还是个八股文考试，有很大可能学了用不上（毕竟对于考生的工作年限是没有要求的）；而且软考是水平考试而不是资格考试，做开发也没有任何资格壁垒（不像建筑）。&lt;/p&gt;
&lt;h2 id=&#34;软考的考试内容&#34;&gt;软考的考试内容&lt;/h2&gt;
&lt;p&gt;既然是考试，最重要的当然是考什么。好在这个问题并不难回答，看教材就好了。架构师的教材名叫《系统架构设计师教程（第2版）》，大体上可以分为两个部分；第一部分是综合知识，其中一些章节接受过科班 CS 教育的人稍作复习即可（计算机系统、信息安全、数据库设计），另外一些章节则之前学的不够深入或者是首次接触，需要学习（软件工程、架构设计、质量属性、软件可靠性、架构演进）；第二部分是各类架构的详细介绍，总共划分了八大架构（信息系统、层次式、云原生、SOA、嵌入式、通信系统、安全、大数据），每个架构内会有概述、设计、优缺点、适用场景、示例等。&lt;/p&gt;
&lt;p&gt;和考试内容同等重要的，还有考试形式。软考高级资格的考试是 3 个科目：综合知识（单选，75题）、案例分析（简答，1必选+4选2）、论文（4选1，2k字+）。（是不是有种高中语文的感觉了？）每个科目满分 75 分，及格线是 45 分。所有科目都及格才能通过。其中综合知识和案例分析上午连着考，论文则是下午单独考。每个科目的考试时间都是 2 个小时。这其中综合知识和案例分析，基本上靠刷题可以覆盖掉，然而论文就是一个大坑了，毕竟2个小时时间，要完成选题、构思、写作、检查，而且字数还要求2k以上，如果没有训练过实在是比较困难。（顺带一提，23年下半年之前，软考是纸质考试，论文当然也是要手写的；好在23年下半年开始改为了机考，论文也可以打字作答了；真不敢想象之前的考生是如何考过的）。&lt;/p&gt;
&lt;h2 id=&#34;备考资料&#34;&gt;备考资料&lt;/h2&gt;
&lt;p&gt;我认为比较有用的资料有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;书《系统架构师设计师考试 32小时通关》（作者：薛大龙）：基本上是教材的精简版本，还带有简单的例题；初期可以先用这本书读一遍，建立下知识框架（软考官方教材不要买纸质书，又厚又重；找 PDF 就够了）&lt;/li&gt;
&lt;li&gt;软考备考资料：&lt;a href=&#34;https://github.com/xxlllq/system_architect&#34;&gt;https://github.com/xxlllq/system_architect&lt;/a&gt;；虽然 repo 里有些东西，但是大部分资源还是要付费后从阿里云盘获取；虽然这些资料自己逐个找也可以找出来，但是相对于花的时间和精力来说，花点小钱（￥20）一次找全还是划算的&lt;/li&gt;
&lt;li&gt;小程序《软考达人》：刷题用（综合知识和案例分析）；单纯刷题的话完全免费，不需要付费也不用加群&lt;/li&gt;
&lt;li&gt;B站视频课程（up 主：文老师软考教育）：&lt;a href=&#34;https://www.bilibili.com/video/BV1Dy4y1a71j&#34;&gt;https://www.bilibili.com/video/BV1Dy4y1a71j&lt;/a&gt;；时间比较紧，就看了论文的两 P，对梳理论文结构很有帮助（e.g.十段式）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总体上，最必须的书 + 资料大概五六十元就可以拿下；是否要买课或者是报班就见仁见智了。&lt;/p&gt;
&lt;h2 id=&#34;备考时间线&#34;&gt;备考时间线&lt;/h2&gt;
&lt;p&gt;基本上备考时间只有 2 个月，核心的学习时间大概是 60 小时（18 小时读书建立框架、30 小时刷题、12 小时考前临时抱佛脚）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报名：2024/3/25&lt;/li&gt;
&lt;li&gt;建立框架：2024/4/4 ~ 2024/4/6，趁着清明假期，把 32 小时通关读了一边，顺带做了下书上的例题&lt;/li&gt;
&lt;li&gt;综合知识刷题：2024/4，基本上是上班的地铁上刷题，一开始刷综合知识的选择题，到了4月底，基本上能保证在40分钟内完成且分数高于及格线了；这一阶段硬刷就是了，很多知识点都是边刷边熟悉的，错了也不用太担心，下次还会遇到的&lt;/li&gt;
&lt;li&gt;案例分析刷题：2024/5，也是在上班地铁上，小程序的题库量比较少（120题左右），但是案例分析比选择复杂很多，所以可能一天只能刷个三四题；我自己的做法是先读题，自己想怎么回答，然后看参考答案，根据参考答案补全自己的答案（因为不方便用纸笔，基本上都是脑内过一下就完了）&lt;/li&gt;
&lt;li&gt;考前抱佛脚：2024/5/24（考前一天）；因为一些工作上的调整，5月开始每周的工作量都很大，周中已经很累了，周末也完全提不起精神去学习；眼看着马上就要考试了，报名费还挺贵的，这次没过还不知道是否有自信再来一次，思来想去还是考前请了一天假，去图书馆专心复习，能复习多少算多少吧；最后这一天从早9点一直学到晚上10点图书馆关门，虽然不确定学进去多少，但是至少心态上自信多了
&lt;ul&gt;
&lt;li&gt;错题整理：过了下之前刷题阶段的错题，一些知识点回到教材重新梳理知识脉络，编一些自己能记住的记忆口诀（例如 六大质量属性 APTSUM：A可用性 P性能 T可测试性 S安全性 U易用性 M可修改性）&lt;/li&gt;
&lt;li&gt;看论文网课：说来惭愧，之前一直都没写过论文，于是先B站找了个网课看下（就是上面备考资料写的），了解了十段式（项目概要+正文概要+项目背景+项目组成+子题目回应+正文论点3+总结+不足）&lt;/li&gt;
&lt;li&gt;写一篇论文：学完了论文结构之后，就立刻写了一篇试试看（不然一篇没写过上考场准完蛋，写一篇可能还有点盼头）；题目是随便想的，考虑到 LLM 发展如火如荼，自己定了个《大语言模型和人工智能技术在软件系统开发中的应用》的题目；然后就努力花了 4 个小时憋出了第一篇论文，对照着论文网课还有其他资料中的论文范文又继续改了改；然后整理了所有押题的论文题目，想自己的项目怎么套上去&lt;/li&gt;
&lt;li&gt;考前资料整理：把认为考前需要复习的内容（常错的知识点、案例分析套路、论文架构、自己瞎编的论文）拼成了一个文档打印出来，考前背诵用，也安心一些&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;考试：2024/5/25
&lt;ul&gt;
&lt;li&gt;综合知识：有些点忘了，有些完全没见过，但是好在之前刷的题够多，75 题中自己完全确定答案一定正确的就有 48 题，这部分应该是稳了&lt;/li&gt;
&lt;li&gt;案例分析：必选题是质量效应树和微服务架构，开考前刚背过；4个自选题选了大数据（mongodb、nosql）和 UML 时序图，剩下的两个（嵌入式和分布式锁）感觉不太稳没敢选&lt;/li&gt;
&lt;li&gt;论文：题目有模型驱动架构设计、单元测试、云上自动化运维、大数据lambda架构；刚好最近在做一些数据系统的工作，于是选了大数据lambda架构的题目；内容上虽然参杂了一些工作上的技术，但是主体大部分还是瞎编+课本知识的混合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查询成绩：2024/6/24，通过，综合知识 56，案例分析 52，论文 52；只能说运气很好，论文编的合判卷人口味了&lt;/li&gt;
&lt;li&gt;领实体证书：2024/7/25&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2024/07/25/nT1HWFOMlo2qKXf.png&#34; alt=&#34;cert.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;感受和建议&#34;&gt;感受和建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;对于科班 CS，有实际开发经验的同学来说，这个考试并不算非常困难（10分最难的话，大概是7~8分的水平），但是依然要花时间准备（主要是刷足够多的题）&lt;/li&gt;
&lt;li&gt;论文真的很看运气，本次是运气好，可选的题目里有一个和我最近的工作相关的题目；如果没有这个题目可能我就跪了；最好要掌握如何把自己做过的项目套到论文题目上&lt;/li&gt;
&lt;li&gt;写作速度很重要，论文的 2 小时我基本上前 5 分钟在选题和构思，后面就一直在写了，结束前 2 分钟才完稿，时间非常紧张&lt;/li&gt;
&lt;li&gt;如果你是学生，有比较多的空闲时间，不妨去考下试试看，反正也不要求工作年限&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;和正文无关的一些碎碎念：上次写考试相关的文章，还是 2021 年 &lt;a href=&#34;https://nekonull.me/posts/tf-cert-blog/&#34;&gt;7 天 TensorFlow 开发者认证&lt;/a&gt;的那一篇。那篇文章意外上了阮老师的周刊，还给本博客增加了不少流量。现在回过头来看看 ML 领域 PyTorch 几乎已经一家独大，TF 如风中残烛，更别提 LLM 的突飞猛进，当年的认证回头来看其实除了满足虚荣心+能写在简历上之外，并没有起到实质性的作用。前几天收到 Google 的邮件，说当时考的认证已经过期了（有效期只有三年），问我还要不要再续（实际上就是再考一次），那当然就选择不考了。虽然软考没有有效期，不存在重考的问题，但在决定投入精力被考前，依然得好好想想是否真的「对我有用」。&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;本文发出后的修正&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修复了关于退税的表述（2024/8/7）&lt;/li&gt;
&lt;li&gt;修了错误的日期描述；“基础知识”改为“综合知识”；补充证书图片（2024/8/9）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>读书记录《软件设计的哲学（第2版）》</title>
      <link>https://nekonull.me/share/book-philosophy-software-design-2nd/</link>
      <pubDate>Sun, 28 Jul 2024 21:34:58 +0800</pubDate>
      
      <guid>https://nekonull.me/share/book-philosophy-software-design-2nd/</guid>
      <description>&lt;p&gt;书名：A Philosophy of Software Design (2nd Edition)&lt;/p&gt;
&lt;p&gt;评价：8.5/10；一开始是看到封面感觉很棒，于是就找来读了下；不是很长，三四个小时就能读完；虽然内容比较基本，但是能系统化的重新复习下也挺好的&lt;/p&gt;
&lt;p&gt;版本：anna&amp;rsquo;s archive，llm翻译为中文&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;软件设计的原则&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;复杂性的管理
&lt;ul&gt;
&lt;li&gt;复杂性源自依赖和晦涩的累积；随着复杂性增加，它导致变更放大、高认知负荷以及未知的未知因素
&lt;ul&gt;
&lt;li&gt;变更放大：一个看似简单的改动需要在多处修改代码&lt;/li&gt;
&lt;li&gt;认知负荷：为了进行更改，开发者必须积累大量信息。&lt;/li&gt;
&lt;li&gt;未知的未知：尚不清楚需要修改哪些代码，或者为了进行这些修改必须考虑哪些信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因此，实现每个新功能需要更多的代码修改。此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最糟糕的情况下，他们甚至无法找到所需的所有信息。底线是，复杂性使得修改现有代码库变得困难且充满风险。&lt;/li&gt;
&lt;li&gt;向下转移复杂性最有意义的情况是：（a）被转移的复杂性与类的现有功能紧密相关，（b）转移复杂性将导致应用程序其他部分的简化，以及（c）转移复杂性简化了类的接口。记住，目标是最小化整个系统的复杂性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模块化与接口设计
&lt;ul&gt;
&lt;li&gt;在设计类和其他模块时，最重要的议题是使它们具有深度，以便为常见用例提供简单的接口，同时仍能提供重要的功能。&lt;/li&gt;
&lt;li&gt;在将系统分解为模块时，尽量避免受到运行时操作顺序的影响；这会导致时间分解，从而引发信息泄露和浅层模块。&lt;/li&gt;
&lt;li&gt;软件设计中最关键的要素之一就是确定谁需要知道什么，以及何时需要知道。当细节至关重要时，最好将它们明确且尽可能显而易见地展现出来&lt;/li&gt;
&lt;li&gt;多个方法可以拥有相同的签名，只要它们各自提供有用且独特的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码简化与重构
&lt;ul&gt;
&lt;li&gt;在编写详细代码时，简化代码最有效的方法之一是消除特殊情况&lt;/li&gt;
&lt;li&gt;特殊情况可能导致代码充斥着if语句，这使得代码难以理解且容易产生错误。因此，应尽可能消除特殊情况。最佳的做法是通过设计正常情况，使其自动处理边缘条件，而无需额外代码。&lt;/li&gt;
&lt;li&gt;如果你为了减少方法数量而不得不引入大量额外参数，那么你可能并没有真正简化问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从基础开始&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;变量与方法的命名规范
&lt;ul&gt;
&lt;li&gt;因此，你不应满足于仅仅是“合理接近”的命名。花一些额外的时间来挑选精确、无歧义且直观的优秀名称。这份额外的关注将很快得到回报，随着时间的推移，你将学会迅速选择好的名称。&lt;/li&gt;
&lt;li&gt;名称“cursorVisible”传达了更多信息；例如，它让读者能够猜测真值的含义（通常情况下，布尔变量的名称应始终为谓词形式）。名称中不再包含“blink”一词，因此如果读者想知道为什么光标并非始终可见，他们需要查阅文档；这部分信息相对不那么重要。&lt;/li&gt;
&lt;li&gt;如果你发现很难为一个特定变量想出一个既精确、直观又不太长的名字，这是一个警示信号。这表明该变量可能没有明确的定义或目的。当这种情况发生时，考虑采用其他分解方法。例如，也许你试图用一个单一变量来表示多个事物；如果是这样，将表示分解为多个变量可能会使每个变量的定义更简单。选择好名字的过程可以发现设计中的弱点，从而改进你的设计。&lt;/li&gt;
&lt;li&gt;名称中的每个单词都应提供有用信息；那些无助于阐明变量含义的词汇只会增加冗余（例如，它们可能导致更多行换行）。一个常见的错误是在名称中添加诸如“field”或“object”之类的通用名词，比如“fileObject”。在这种情况下，“Object”这个词很可能并未提供有用信息（是否存在不是对象的文件？），因此应从名称中省略。&lt;/li&gt;
&lt;li&gt;杰兰德的一个观点我深表赞同：“一个名称的声明与其使用之间的距离越远，该名称就应该越长。”之前关于使用名为i和j的循环变量的讨论，正是这一规则的例证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码结构的清晰性与可读性
&lt;ul&gt;
&lt;li&gt;仅凭方法的长度本身很少是拆分方法的充分理由。通常情况下，开发者倾向于过度拆分方法。拆分方法会引入额外的接口，增加了复杂性。同时，它将原方法的各个部分分离，如果这些部分实际上是相关的，这会使代码更难以阅读。除非拆分方法能使整个系统变得更简单，否则不应进行拆分&lt;/li&gt;
&lt;li&gt;长方法并不总是坏事。例如，假设一个方法包含五个20行代码的块，这些块按顺序执行。如果这些块相对独立，那么方法可以逐块阅读和理解；将每个块移到单独的方法中并没有太大好处。如果这些块之间有复杂的交互，那么将它们放在一起就更为重要，以便读者可以一次性看到所有代码；如果每个块都在单独的方法中，读者将不得不在这些分散的方法之间来回翻阅，以理解它们是如何协同工作的。包含数百行代码的方法如果具有简单的签名并且易于阅读，那么它们也是很好的。这些方法是深层的（功能丰富，接口简单），这是好事&lt;/li&gt;
&lt;li&gt;深度比长度更重要：首先确保函数有足够的深度，然后再尝试使其足够短以便轻松阅读。不要为了长度牺牲深度。决定拆分或合并模块应基于复杂度。选择能实现最佳信息隐藏、最少依赖关系及最深接口的结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释的重要性与编写技巧
&lt;ul&gt;
&lt;li&gt;优质的注释能显著提升软件的整体质量；编写优质注释并不难；而且（这可能难以置信）编写注释实际上可以很有趣。&lt;/li&gt;
&lt;li&gt;注释通过提供不同层次的详细信息来增强代码。有些注释提供比代码更低的、更详细的层次信息；这些注释通过阐明代码的确切含义来增加精确性。其他注释提供比代码更高的、更抽象的层次信息；这些注释提供直觉，比如代码背后的推理，或者一种更简单、更抽象的思考代码的方式。与代码处于同一层次的注释很可能会重复代码的内容。&lt;/li&gt;
&lt;li&gt;具体的注释方式
&lt;ul&gt;
&lt;li&gt;在注释类实例变量、方法参数和返回值时，精确性尤为重要。变量声明中的名称和类型通常不够精确。注释可以填补缺失的细节，例如：
&lt;ul&gt;
&lt;li&gt;这个变量的单位是什么？&lt;/li&gt;
&lt;li&gt;边界条件是包含性的还是排他性的？&lt;/li&gt;
&lt;li&gt;如果允许空值，这暗示着什么？&lt;/li&gt;
&lt;li&gt;如果一个变量指向一个最终必须被释放或关闭的资源，那么谁负责释放或关闭它？&lt;/li&gt;
&lt;li&gt;是否存在某些特性（不变量），对于变量而言总是成立，例如“这个列表始终至少包含一个条目”？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在记录变量时，应考虑名词而非动词。换言之，重点在于变量所代表的内容，而非其如何被操作。&lt;/li&gt;
&lt;li&gt;在记录一个方法时，描述该方法最可能被调用的条件（特别是在方法仅在特殊情况下被调用时）会非常有帮助。&lt;/li&gt;
&lt;li&gt;记录抽象的第一步是将接口注释与实现注释分开。接口注释提供了某人为了使用类或方法所需了解的信息；它们定义了抽象。实现注释描述了类或方法内部如何工作以实现抽象。将这两种注释分开很重要，这样接口的用户就不会接触到实现细节。&lt;/li&gt;
&lt;li&gt;方法接口注释既包含高层次的抽象信息，也包含低层次的精确细节
&lt;ul&gt;
&lt;li&gt;注释通常以一两句话开始，描述调用者感知到的方法行为；这是更高层次的抽象。评论必须详细描述每个参数及其返回值（如有）。&lt;/li&gt;
&lt;li&gt;这些评论必须非常精确，并且必须描述参数值的任何限制以及参数之间的依赖关系。&lt;/li&gt;
&lt;li&gt;如果方法有任何副作用，这些必须在接口注释中记录。副作用是指方法对系统未来行为产生影响的任何后果，但不是结果的一部分。例如，如果方法向内部数据结构添加一个值，该值可以通过未来的方法调用检索，这就是副作用；写入文件系统也是副作用。&lt;/li&gt;
&lt;li&gt;方法的接口注释必须描述该方法可能抛出的任何异常。&lt;/li&gt;
&lt;li&gt;如果在一个方法被调用之前必须满足某些先决条件，这些条件必须被描述出来（可能需要先调用其他方法；对于二分查找方法，被查找的列表必须是已排序的）。尽量减少先决条件是一个好主意，但任何保留的先决条件都必须有文档说明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;幸运的是，有一个明显的地方是开发者在添加新状态值时必须去的，那就是状态枚举的声明处。我们利用这一点，在那个枚举中添加了注释，指出了所有也必须修改的其他地方&lt;/li&gt;
&lt;li&gt;处理跨模块注释：我最近在尝试一种方法，即跨模块问题记录在一个名为designNotes的中央文件中。该文件被清晰地划分为多个标有明确标签的部分，每个部分对应一个主要主题。&lt;/li&gt;
&lt;li&gt;在遵循注释应描述代码中不明显内容的规则时，“明显”是从初次阅读代码的人（而非你本人）的角度出发的。撰写注释时，尝试站在读者的立场，思考他们需要了解的关键信息是什么。如果你的代码正在接受审查，而审查者指出某些内容不明显，不要与他们争论；如果读者认为某处不明显，那么它就是不明显。与其争论，不如尝试理解他们感到困惑的地方，并思考是否能通过更清晰的注释或更优化的代码来阐明。&lt;/li&gt;
&lt;li&gt;一般来说，注释与它所描述的代码之间的距离越远，它就应该越抽象（这样可以降低因代码变动而导致注释失效的可能性）。&lt;/li&gt;
&lt;li&gt;在撰写提交信息时，问问自己：未来开发者是否需要这些信息？如果是，那么请在代码中记录下来。例如，一个描述了促使代码变更的微妙问题的提交信息。如果这未在代码中记录，那么后续开发者可能会在不知情的情况下撤销该变更，从而重新引入一个错误。如果你想在提交信息中也包含这份信息的副本，那当然可以，但最重要的是将其记录在代码中。这体现了将文档置于开发者最可能看到的地方的原则；而提交日志通常并非这样的场所。&lt;/li&gt;
&lt;li&gt;保持注释最新性的第二种技巧是避免重复。如果文档被复制，开发者找到并更新所有相关副本的难度就会增加。相反，尝试对每个设计决策只记录一次。如果代码中多个地方受到某个特定决策的影响，不要在这些点重复文档。而是找到最显眼的单一位置放置文档。例如，假设某个变量的行为复杂，影响到该变量使用的多个不同地方。你可以在变量声明旁边的注释中记录这种行为。这是一个自然的位置，开发者在理解使用该变量的代码遇到困难时很可能会查看。&lt;/li&gt;
&lt;li&gt;对于更局部化的约定，例如不变量，找到代码中合适的位置来记录它们。如果你不将这些约定写下来，其他人很可能不会遵循它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;何时测试
&lt;ul&gt;
&lt;li&gt;测试，尤其是单元测试，在软件设计中扮演着重要角色，因为它们促进了重构。没有测试套件，对系统进行重大结构改动是危险的。没有简单的方法来发现错误，因此错误很可能会在新代码部署后才被发现，那时发现和修复错误的成本要高得多。因此，在没有良好测试套件的系统中，开发者会避免重构；他们试图为每个新功能或错误修复最小化代码更改的数量，这意味着复杂性积累，设计错误得不到纠正。有了良好的测试集，开发者在重构时可以更有信心，因为测试套件会发现大多数引入的错误。这鼓励开发者对系统进行结构上的改进，从而得到更好的设计。&lt;/li&gt;
&lt;li&gt;测试驱动开发的问题在于，它将注意力集中在使特定功能正常工作上，而不是寻找最佳设计。这纯粹是战术编程，带有其所有的不利之处。测试驱动开发过于渐进：在任何时候，都很容易为了通过下一个测试而匆匆添加下一个功能。没有明显的时间进行设计，因此很容易陷入混乱&lt;/li&gt;
&lt;li&gt;在修复 bug 时，先编写测试是一个合理的做法。在修复 bug 之前，先写一个因为该 bug 而失败的单元测试。然后修复 bug，并确保单元测试现在通过。这是确保你真正修复了 bug 的最佳方法。如果你在编写测试之前就修复了bug，那么新的单元测试可能实际上并未触发该 bug，这种情况下它将无法告诉你是否真正解决了问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计模式的应用
&lt;ul&gt;
&lt;li&gt;不要试图将问题强行套入某个设计模式，而应采用更简洁的自定义方法。使用设计模式并不意味着自动提升软件系统的质量；只有当设计模式恰到好处时，才能发挥其优势。&lt;/li&gt;
&lt;li&gt;每当你遇到一个新的软件开发范式的提议时，从复杂性的角度对其进行质疑：这个提议是否真的有助于减少大型软件系统的复杂性？许多提议表面上听起来不错，但如果你深入探究，你会发现其中一些实际上使复杂性变得更糟，而非更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具体做法&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设计两次
&lt;ul&gt;
&lt;li&gt;我注意到，“设计两次”原则有时对非常聪明的人难以接受。在他们成长的过程中，聪明人发现他们对任何问题的第一个快速想法就足以获得好成绩；没有必要考虑第二个或第三个可能性。这往往导致不良的工作习惯。然而，随着这些人年龄的增长，他们被提拔到面临越来越困难问题的环境中。最终，每个人都会达到一个阶段，即你的第一个想法不再足够好；如果你想取得真正出色的成果，无论你多么聪明，你都必须考虑第二个可能性，甚至可能是第三个。大型软件系统的设计就属于这一类：没有人能够一次就做得完美。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释先行的开发
&lt;ul&gt;
&lt;li&gt;最佳的注释编写时机是在过程的开始，即编写代码的同时。先编写注释使得文档成为设计过程的一部分。这不仅能产生更好的文档，还能带来更优秀的设计，并且使编写文档的过程更加愉快。&lt;/li&gt;
&lt;li&gt;先写注释意味着在开始编码前，抽象概念会更加稳定。这很可能会在编码过程中节省时间。相反，如果先写代码，抽象概念可能会随着编码的进行而演变，这需要比先写注释的方法更多的代码修订。综合考虑这些因素，整体上先写注释可能会更快。
&lt;ul&gt;
&lt;li&gt;对于一个新类，我首先撰写类接口注释。&lt;/li&gt;
&lt;li&gt;接下来，我会为最重要的公共方法编写接口注释和签名，但我会让方法体保持空白。&lt;/li&gt;
&lt;li&gt;我稍微反复斟酌这些评论，直到基本结构感觉差不多合适。&lt;/li&gt;
&lt;li&gt;在此，我为类中最重要的实例变量撰写声明和注释。&lt;/li&gt;
&lt;li&gt;最后，我填充了方法的主体，并在必要时添加了实现注释。&lt;/li&gt;
&lt;li&gt;在编写方法体时，我通常会发现需要额外的属性和实例变量。对于每个新写的方法，我会在方法体之前先写接口注释；对于实例变量，我会在写变量声明的同时填写注释。&lt;/li&gt;
&lt;li&gt;当代码完成时，注释也已完成。从未有过未编写的注释积压。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能优化与重构
&lt;ul&gt;
&lt;li&gt;一旦你对什么是昂贵、什么是便宜有了大致的了解，你就可以利用这些信息尽可能选择便宜的操作。在很多情况下，更高效的方法可能和较慢的方法一样简单。&lt;/li&gt;
&lt;li&gt;再举一个例子，考虑在C或C++这样的语言中分配一个结构体数组。有两种方法可以实现这一点。一种方法是将数组用于保存指向结构体的指针，在这种情况下，你必须首先为数组分配空间，然后为每个单独的结构体分配空间。将结构体直接存储在数组中要高效得多，这样你只需为所有内容分配一个大的内存块。&lt;/li&gt;
&lt;li&gt;一般来说，代码越简单，运行速度往往越快。如果你已经定义并处理了特殊情况和异常，那么就不需要额外的代码来检查这些情况，系统运行速度自然更快。深层类比浅层类更高效，因为每次方法调用它们能完成更多工作。浅层类会导致更多的层级跨越，而每次层级跨越都会增加开销。&lt;/li&gt;
&lt;li&gt;在进行任何更改之前，应测量系统的现有行为。这有两个目的。首先，这些测量将确定性能调优影响最大的地方。仅仅测量顶层系统性能是不够的。这可能告诉你系统太慢，但不会告诉你原因。你需要更深入地测量，以详细识别影响整体性能的因素；目标是找出系统当前花费大量时间的少数特定位置，并且你有改进的想法。测量的第二个目的是提供一个基准，这样你可以在更改后重新测量性能，以确保性能确实得到了提升。如果更改没有使性能产生可测量的差异，那么就撤销这些更改（除非它们使系统更简单）。除非能显著加快系统速度，否则保留复杂性是没有意义的。&lt;/li&gt;
&lt;li&gt;改进其性能的最佳方法是进行“根本性”的改变，比如引入缓存，或者采用不同的算法方法（例如平衡树与列表）。&lt;/li&gt;
&lt;li&gt;首先，问问自己，在常见情况下，为了完成所需任务，必须执行的最少代码量是多少。忽略任何现有的代码结构。想象一下，你正在编写一个新方法，只实现关键路径，即在大多数常见情况下必须执行的最少代码量。当前的代码可能充斥着特殊情况；在这个练习中忽略它们。当前的代码可能在关键路径上经过多个方法调用；想象一下，你可以将所有相关代码放在一个方法中。当前的代码也可能使用多种变量和数据结构；只考虑关键路径所需的数据，并假设任何数据结构对关键路径最为方便。例如，将多个变量合并为一个值可能是有意义的。假设你可以完全重新设计系统，以最小化关键路径必须执行的代码量。我们称这种代码为“理想状态”。&lt;/li&gt;
&lt;li&gt;在为性能进行重构时，应尽量减少必须检查的特殊情况数量。理想情况下，开始处应只有一个if语句，通过一次测试就能检测所有特殊情况。在正常情况下，只需进行这一次测试，之后关键路径即可无须额外特殊情况测试地执行。如果初始测试未通过（意味着出现了特殊情况），代码可以跳转到关键路径之外的独立位置处理该情况。&lt;/li&gt;
&lt;li&gt;清晰的设计与高性能是可以兼容的。Buffer类的重写不仅使其性能提升了两倍，同时简化了设计并减少了20%的代码量。复杂的代码往往运行缓慢，因为它执行了多余或重复的工作。相反，如果你编写清晰、简洁的代码，你的系统很可能已经足够快速，以至于你无需过多担心性能问题。在少数确实需要优化性能的情况下，关键仍然是简洁性：找出对性能至关重要的关键路径，并尽可能简化它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遵守约定和惯例
&lt;ul&gt;
&lt;li&gt;一旦发现任何看似约定的做法，就应遵循。在进行设计决策时，问问自己这个决策是否可能在项目的其他地方也有类似的选择；如果有，找到一个现成的例子，并在你的新代码中采用相同的方法。&lt;/li&gt;
&lt;li&gt;不要改变现有的惯例。抵制那种想要“改进”现有惯例的冲动。拥有一个“更好的想法”并不是引入不一致性的充分理由。你的新想法可能确实更好，但一致性相对于不一致性的价值几乎总是大于一种方法相对于另一种方法的价值。在引入不一致行为之前，问自己两个问题。首先，你是否拥有重要的新信息来证明你的方法，而这些信息在旧惯例建立时是不可用的？其次，新方法是否好到值得花时间去更新所有旧的使用？如果你的组织同意这两个问题的答案都是“是”，那么就大胆进行升级；完成后，旧惯例的痕迹应该荡然无存。然而，你仍然面临风险，即其他开发者可能不知道新惯例，因此他们未来可能会重新引入旧方法。总的来说，重新考虑已建立的惯例很少是开发者时间的良好利用。&lt;/li&gt;
&lt;li&gt;“显而易见”存在于读者心中：注意到他人代码的不明显之处比发现自己的代码问题要容易得多。因此，判断代码是否显而易见的最佳方法是通过代码审查。如果有人阅读你的代码后认为它不明显，那么它就是不明显的，无论对你来说它看起来多么清晰。通过努力理解是什么使得代码不明显，你将学会如何在将来编写更好的代码。&lt;/li&gt;
&lt;li&gt;代码如果符合读者预期的惯例，则最为直观；如果不符合，那么记录这种行为就很重要，以免读者感到困惑。&lt;/li&gt;
&lt;li&gt;为了使代码显而易见，你必须确保读者始终拥有理解代码所需的信息。你可以通过三种方式来实现这一点。最佳方法是减少所需的信息量，运用抽象和消除特殊情况等设计技巧。其次，你可以利用读者在其他情境中已获得的信息（例如，通过遵循惯例和符合预期），这样读者就不必为你的代码学习新信息。第三，你可以通过使用良好的命名和策略性注释等技巧，在代码中向他们展示重要信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正确对待事件驱动编程
&lt;ul&gt;
&lt;li&gt;事件驱动编程使得跟踪控制流程变得困难。事件处理函数从未被直接调用；它们是通过事件模块间接调用的，通常使用函数指针或接口。即使你在事件模块中找到了调用点，仍然无法确定具体会调用哪个函数：这取决于运行时注册了哪些处理程序。因此，很难对事件驱动代码进行推理，或者确信其工作正常。&lt;/li&gt;
&lt;li&gt;为了弥补这种晦涩，请在每个处理函数接口注释中指明其何时被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免使用通用容器
&lt;ul&gt;
&lt;li&gt;不幸的是，通用容器导致代码不直观，因为被分组的元素具有模糊其含义的通用名称。在上述示例中，调用者必须使用result.getKey()和result.getValue()来引用两个返回值，这无法提供关于值实际含义的任何线索。&lt;/li&gt;
&lt;li&gt;因此，最好不要使用通用容器。如果你需要一个容器，可以定义一个专门针对特定用途的新类或结构。这样，你就可以为元素使用有意义的名称，并在声明中提供额外的文档，这是通用容器无法做到的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透传变量与上下文
&lt;ul&gt;
&lt;li&gt;透传变量增加了复杂性，因为它们迫使所有中间方法都意识到它们的存在，即便这些方法并不需要使用这些变量。此外，如果一个新的变量出现（例如，系统最初构建时未支持证书，但后来决定添加该支持），你可能需要修改大量接口和方法，以确保该变量能够通过所有相关路径传递。&lt;/li&gt;
&lt;li&gt;我最常用的解决方案是引入一个上下文对象，如图7.2(d)所示。上下文存储了应用程序的所有全局状态（任何原本需要传递的变量或全局变量）。上下文远非理想的解决方案。&lt;/li&gt;
&lt;li&gt;存储在上下文中的变量大多具有全局变量的缺点；例如，可能不明显为什么存在某个特定变量，或者它在何处被使用。如果没有纪律，上下文可能会变成一个巨大的数据杂烩，在整个系统中产生不明显的依赖关系。上下文还可能引发线程安全问题；避免问题的最佳方式是使上下文中的变量不可变。遗憾的是，我尚未找到比上下文更好的解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异常处理和配置参数
&lt;ul&gt;
&lt;li&gt;这些方法在短期内会让你的生活更轻松，但它们增加了复杂性，导致许多人必须处理一个问题，而不是仅仅一个人。例如，如果一个类抛出异常，该类的每个调用者都必须处理它。如果一个类导出配置参数，每个安装环境中的每个系统管理员都必须学习如何设置它们。&lt;/li&gt;
&lt;li&gt;因此，应尽可能避免使用配置参数。在导出配置参数之前，自问：“用户（或更高级别的模块）能否确定比我们在此处确定的更优值？”当确实需要创建配置参数时，尝试提供合理的默认值，以便用户仅在特殊情况下才需提供值。理想情况下，每个模块应完整解决问题；配置参数导致解决方案不完整，从而增加了系统复杂性。&lt;/li&gt;
&lt;li&gt;抛出异常容易，处理异常却难。因此，异常的复杂性主要来源于异常处理代码。减少异常处理带来的复杂性损害的最佳方法，是减少需要处理异常的地方。&lt;/li&gt;
&lt;li&gt;异常屏蔽并非在所有情况下都有效，但在其适用的场合，它是一个强有力的工具。它能够产生更深层次的类，因为它减少了类的接口（用户需要了解的异常更少），并以屏蔽异常的代码形式增加了功能。异常屏蔽是向下转移复杂性的一个例子&lt;/li&gt;
&lt;li&gt;最佳方法是重新定义语义以消除错误条件。对于无法消除的异常，应寻找机会在较低层次上屏蔽它们，从而限制其影响，或者将多个特殊情况处理程序聚合为一个更通用的处理程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件设计的哲学与美学&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;时刻重构
&lt;ul&gt;
&lt;li&gt;如果你想为一个系统保持一个干净的设计，在修改现有代码时必须采取战略性的方法。理想情况下，当你完成每一项改动后，系统应具备如果从一开始就考虑到这些改动而设计的结构。为了实现这一目标，你必须抵制快速修复的诱惑。相反，要思考当前的系统设计是否仍然是最佳的，考虑到所需的改动。如果不是，就重构系统，以便最终获得尽可能最佳的设计。通过这种方法，系统设计随着每一次修改而不断改进。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计的重要性与价值
&lt;ul&gt;
&lt;li&gt;良好软件设计的一个重要元素是区分重要与不重要。应以重要的事物为核心构建软件系统。对于不太重要的事物，应尽量减少它们对系统其余部分的影响。重要的事物应加以强调并使其更加明显；不重要的事物则应尽可能隐藏。&lt;/li&gt;
&lt;li&gt;一旦你确定了重要的事物，你应该在设计中强调它们。强调的一种方式是通过突出：重要的事物应该出现在更可能被看到的地方，比如界面文档、名称或频繁使用的方法的参数。另一种强调的方式是通过重复：关键的想法反复出现。第三种强调的方式是通过中心性。最重要的事物应该位于系统的核心，它们决定了周围事物的结构。一个例子是操作系统中设备驱动的接口；这是一个核心想法，因为成百上千的驱动程序将依赖于它。&lt;/li&gt;
&lt;li&gt;专注于最重要的事物的理念不仅适用于软件设计，在技术写作领域也同样重要：使文档易于阅读的最佳方法是在开头识别几个关键概念，并围绕它们构建文档的其余部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件开发中的“好品味”
&lt;ul&gt;
&lt;li&gt;“好品味”这一短语描述了区分重要与不重要事物的能力。拥有好品味是成为优秀软件设计师的重要组成部分。&lt;/li&gt;
&lt;li&gt;成为优秀设计师的回报是，你能够将更多时间投入到充满乐趣的设计阶段。而糟糕的设计师则大部分时间都在复杂且脆弱的代码中追踪错误。如果你提升自己的设计技能，你不仅能更快地产出更高质量的软件，而且软件开发过程本身也会变得更加愉快。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>2024 年了，我最近在用什么工具</title>
      <link>https://nekonull.me/posts/tools-i-use-2024-mid/</link>
      <pubDate>Sun, 21 Jul 2024 21:53:00 +0800</pubDate>
      
      <guid>https://nekonull.me/posts/tools-i-use-2024-mid/</guid>
      <description>&lt;h2 id=&#34;2024-年了我最近在用什么工具&#34;&gt;2024 年了，我最近在用什么工具&lt;/h2&gt;
&lt;p&gt;去年年中，公司的主力开发设备从 Windows 换成了 Mac，之前在 Windows 上用的各类工具需要重新在 Mac 上找对应的替代品。一年磨合下来现在已经差不多稳定了，特此记录（其实之前就应该记录的，但是太懒）。如果能帮助到各位读者就更好了。当然也欢迎评论推荐更多你认为好用的工具。&lt;/p&gt;
&lt;h2 id=&#34;独立工具&#34;&gt;独立工具&lt;/h2&gt;
&lt;p&gt;（此处的独立指的是软件本身可以独立运行，与之相对的是插件）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VS Code&lt;/a&gt;：宇宙 IDE（装了足够多插件之后）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kate-editor.org/&#34;&gt;Kate&lt;/a&gt;：KDE 家的文本编辑器，功能齐全但是又没有 VS Code 那么重，临时处理些文本比较方便；之前不支持 M 系列处理器，2024 年初更新后总算支持了&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cudatext.github.io/&#34;&gt;CudaText&lt;/a&gt;：用来当作思维 buffer，优点是自带置顶（其他软件都很难做到）和自动保存，目前已经开了 100+ Untitled Tab 了但是依然很稳定&lt;/li&gt;
&lt;li&gt;Apple Notes：用来记录手头临时的待办事项，避免消息太多跟丢&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://obsidian.md/&#34;&gt;Obsidian&lt;/a&gt;：用来做&lt;a href=&#34;https://news.ycombinator.com/item?id=40950584&#34;&gt;工作笔记&lt;/a&gt;，其实就是对每个任务建一个文件，然后把所有相关信息全部丢进去；偶尔也用用 canvas 功能&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.u.tools/&#34;&gt;Utools&lt;/a&gt;：小工具聚合器，例如 JSON 格式化、二维码生成、base64编解码、timestamp 生成和解析、变量名大小写转换；绑定到 Opt+Space&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.raycast.com/&#34;&gt;RayCast&lt;/a&gt;：主要用来窗口切换和左右分屏，其他的功能用的不多；绑定到 Alt+Space&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.snipaste.com/&#34;&gt;Snipaste&lt;/a&gt;：截图 &amp;amp; 贴图是我工作流的重要部分，已经完全离不开了&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://karabiner-elements.pqrs.org/&#34;&gt;Karabiner-Elements&lt;/a&gt;：之前从 Windows 切换过来的时候用于改键（左 Ctrl -&amp;gt; 左 Cmd）；现在键位熟悉之后用的不多了&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dwarvesf/hidden&#34;&gt;Hidden Bar&lt;/a&gt;：隐藏托盘区域的图标（这居然不是 OS 自带的功能？Windows 用户理解不能）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/p0deje/Maccy&#34;&gt;Maccy&lt;/a&gt;：剪贴板历史（救了我好几次）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/exelban/stats&#34;&gt;Stats&lt;/a&gt;：用来显示内存占用（可能和我的用法相关，虽然已经是 32G 内存的配置了，但是使用超过一周依然会有内存泄漏，内存压力红了之后只能重启）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ther0n/UnnaturalScrollWheels&#34;&gt;UnnaturalScrollWheels&lt;/a&gt;：修复外接鼠标滚动方向相反的问题（我觉得这也应该是个 OS 级别功能）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://draw.io/&#34;&gt;Draw.io&lt;/a&gt;：画各种图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.devontechnologies.com/apps/freeware#:~:text=Spotlight%20for%20Experts-,EasyFind,-Spotlight%20is%20great&#34;&gt;EasyFind&lt;/a&gt;：Windows 文件搜索工具 Everything 的 MacOS 下位替代，但是总比没有强&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/michaelvillar/timer-app&#34;&gt;Timer&lt;/a&gt;：倒计时小工具，拟物风很棒；用来提醒我该在发布单上点击下一步了&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ezip.awehunt.com/&#34;&gt;MacZip&lt;/a&gt;：用了这么久 Mac 还是不能适应双击压缩文件自动解压的逻辑，还是能先预览下压缩包内容比较好&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ArchGPT/insomnium&#34;&gt;Insomnium&lt;/a&gt;：类 Postman 工具，但不用登录在线账户，local-first；虽然已经停止开发，但是功能已经足够齐全了&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://activitywatch.net/&#34;&gt;ActivityWatch&lt;/a&gt;：记录下今天上了多少班&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chatboxai.app/&#34;&gt;Chatbox&lt;/a&gt;：最好用的 OpenAI API 客户端，支持刷新上下文、显示 token 用量、消息修改、消息重放（btw 自认为目前用下来综合表现最强的 LLM 是 deepseek-coder，便宜大碗也足够智能）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;obsidian-插件&#34;&gt;Obsidian 插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://publish.obsidian.md/hub/02&amp;#43;-&amp;#43;Community&amp;#43;Expansions/02.05&amp;#43;All&amp;#43;Community&amp;#43;Expansions/Plugins/obsidian-electron-window-tweaker&#34;&gt;Electron Window Tweaker&lt;/a&gt;：让 Obsidian 窗口也能够置顶&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Vinzent03/obsidian-git&#34;&gt;Git&lt;/a&gt;：自动把变更提交到 Git 库，避免数据丢失（我设置的是 10 分钟一次）；另外偶尔看看 blame 还有成就感（原来这个文件已经被我改了这么多次了）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://publish.obsidian.md/tasks/Introduction&#34;&gt;Tasks&lt;/a&gt;：将所有文件里的任务收集起来，创建统一的任务视图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hdykokd/obsidian-vertical-tabs-view&#34;&gt;Vertical Tabs View&lt;/a&gt;：标签页太多的时候，可以用纵向列表列出所有标签页（也和我 Edge 的使用习惯一致）&lt;/li&gt;
&lt;li&gt;[New Tab +]：避免同一个文件被打开在多个 tab 中&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tadashi-aikawa/obsidian-another-quick-switcher&#34;&gt;Another Quick Switcher&lt;/a&gt;：解决 Quick Switch 时，默认搜索结果是按照文件名排序而不是最近修改时间排序的问题&lt;/li&gt;
&lt;li&gt;Unique Note Creator：官方插件，可以直接创建一个带有时间戳的笔记并应用模板；用来在出现新工作时创建对应的工作笔记&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（顺带一提，为了和 VS Code 使用习惯一致，Quick Swtich 绑定到 Cmd+R，command palette 绑定到 Cmd+Shift+P）&lt;/p&gt;
&lt;h2 id=&#34;浏览器插件&#34;&gt;浏览器插件&lt;/h2&gt;
&lt;p&gt;（目前用的是 Edge，纵向标签页没有其他浏览器支持）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://immersivetranslate.com/?force=1&#34;&gt;沉浸式翻译&lt;/a&gt;：外文长文必备&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://modheader.com/&#34;&gt;ModHeader&lt;/a&gt;：调试用，主要拿来改 request header&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inssman.com/&#34;&gt;Inssman&lt;/a&gt;：调试用，主要拿来该 request body（其他的相关插件，例如 Requestly 似乎都要求登录）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/earth-view-from-google-ea/bhloflhklmhfpedakmangadcdofhnnoh?hl=zh-CN&#34;&gt;Earth View From Google Earth&lt;/a&gt;：在新标签页展示航拍景象，换换心情&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chromewebstore.google.com/detail/page-notes/omjdheidbhoghpfdnndkgoelfiogjfla&#34;&gt;Page Notes&lt;/a&gt;：可以保存和某个域名/ URL 相关的笔记；我自己的用法主要是在日志查询页上放一些常见的查询条件，省的来回翻找&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chromewebstore.google.com/detail/picture-in-picture-extens/hkgfoiooedgoejojocmhlaklaeopbecg&#34;&gt;Picture-in-Picture Extension (by Google)&lt;/a&gt;：画中画插件，&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; tag 的视频都能用，摸鱼必备&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chromewebstore.google.com/detail/session-buddy/edacconmaakjimmfgnblocblbcdcpbko&#34;&gt;Session Buddy&lt;/a&gt;：定时备份打开的标签页，对我这种日常 100+ tab 的用户很友好&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chromewebstore.google.com/detail/verticaltabs/imimolldggofidcmfdkcffpjcgaggoaf&#34;&gt;VerticalTabs&lt;/a&gt;：在 tab 之前切换（但后来发现 Cmd+Shift+A 更好用）；现在只是用来显示打开 tab 的个数，超过 150 了就得关一批&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://chromewebstore.google.com/detail/%E7%AF%A1%E6%94%B9%E7%8C%B4/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN&#34;&gt;TamperMonkey&lt;/a&gt;：针对内部不好用的网站，写了很多 JS 小脚本来改善用户体验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有些小工具网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jupyter.org/try-jupyter/lab/&#34;&gt;JupyterLite&lt;/a&gt;：一个基于 WebAssembly 在浏览器内运行 Python 和 Jupyter 的环境，临时写点东西或者调试都很方便&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nekonull.me/day-tracker/&#34;&gt;Day Tracker&lt;/a&gt;：之前自己写的小工具，看今天还要上多久班&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vs-code-插件&#34;&gt;VS Code 插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks&#34;&gt;Bookmarks&lt;/a&gt;：可以给特定的代码行加书签；大代码库或者是逻辑拆的太碎的时候需要&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens&#34;&gt;Error Lens&lt;/a&gt;：行内显示报错信息，不需要手动在波浪线上 hover 也能看到&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight&#34;&gt;Todo Highlight&lt;/a&gt;：将所有 TODO 高亮出来&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens&#34;&gt;GitLens&lt;/a&gt;：和 VS Code 自己的 Git 能力配合使用，就再也用不上其他的 Git GUI 了；行内 Git Blame （浅色文字显示这一行上次的修改来源）和 File History （和该文件相关的所有 commit）很有用&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer&#34;&gt;Live Server&lt;/a&gt;：改 HTML 的时候可以临时起个服务器，文件修改后自动刷新&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph&#34;&gt;Git Graph&lt;/a&gt;：GitLens 的分支图是收费功能，可以用这个插件替代&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow&#34;&gt;indent-rainbow&lt;/a&gt;：缩进可视化&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=njzy.stats-bar&#34;&gt;Stats Bar&lt;/a&gt;：显示机器状态（CPU/内存/网络）；主要用来看云开发机的内存是否又爆炸了&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=meganrogge.template-string-converter&#34;&gt;Template String Converter&lt;/a&gt;：写 TypeScript 必备，输入&lt;code&gt;$&lt;/code&gt;且时自动把当前字符串变量的 &lt;code&gt;&amp;quot;&lt;/code&gt; （一般字符串）换成 &lt;code&gt;`&lt;/code&gt;（模板字符串）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>End of 2023</title>
      <link>https://nekonull.me/posts/end-of-2023/</link>
      <pubDate>Sun, 31 Dec 2023 22:46:01 +0800</pubDate>
      
      <guid>https://nekonull.me/posts/end-of-2023/</guid>
      <description>&lt;h1 id=&#34;end-of-2023&#34;&gt;End of 2023&lt;/h1&gt;
&lt;p&gt;一转眼又到年底了，关注的博主和身边的好友纷纷亮出了自己的年终总结；在这个离跨年还有2个小时不到的时刻，决定还是随手写点，就当给未来的自己留下些印象了。&lt;/p&gt;
&lt;h2 id=&#34;回顾-2023&#34;&gt;回顾 2023&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工作
&lt;ul&gt;
&lt;li&gt;正常升了一级，工资涨了点；但相应的工作量也增加了很多&lt;/li&gt;
&lt;li&gt;可以明显感觉到自己不再被视为新人，而是已经成为了部门战力的一部分&lt;/li&gt;
&lt;li&gt;对负责的业务的复杂性有些感觉，但是了解的依然不够深入；简单的问题可以处理，复杂的问题还是得拉人一起看，没法自己独立解决&lt;/li&gt;
&lt;li&gt;全年负责的部分没有出大事故，但是总感觉有些不安&lt;/li&gt;
&lt;li&gt;开始有完全自己设计的内部系统了，运营也是自己负责&lt;/li&gt;
&lt;li&gt;作为新人参与的第一个项目（参加1年+被交出去），有些不舍&lt;/li&gt;
&lt;li&gt;接近年底的时候接了个很重要很紧急的活，被迫打破自己内向的一面到处找人推进进度，算是体会了一把成为项目owner的感觉&lt;/li&gt;
&lt;li&gt;部门内年中、年末各出现一次大范围组织架构调整，自己所在的小组目前还尚存；同届进来的新人被优化，后续又找到了更好的新工作；自己也应该考虑这方面的可能性了&lt;/li&gt;
&lt;li&gt;干起来还行，虽然不算特别好，但是也不坏；至少可能会先一直干下去，直到哪里突然出现重大变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生活
&lt;ul&gt;
&lt;li&gt;依然住在家里，通勤时间是个比较困扰的问题，但是自己出去租房外短时间内应该无解&lt;/li&gt;
&lt;li&gt;3月眼睛不舒服检查发现左右眼近视远视度数差距过大，开始戴眼镜，估计很长一段时间内都会持续了&lt;/li&gt;
&lt;li&gt;7月检查发现胰岛素抵抗（糖尿病前期），开始定期运动，后来选到了每天中午，边运动边看一集番，从7月开始到12月初天气寒冷结束，中间因为11月生病停了两周，总体运动天数应该在100+&lt;/li&gt;
&lt;li&gt;中午开始不吃公司食堂，成为附近kfc常客，备注不加酱多加菜（这样算下来午餐的热量摄入其实还更低）&lt;/li&gt;
&lt;li&gt;10月去日本旅游了，算是满足了一个自己长久以来的愿望&lt;/li&gt;
&lt;li&gt;开始固定时间去公园散步（以深圳湾公园为主），以及定期的群友聚餐；对维持精神状态有很大帮助&lt;/li&gt;
&lt;li&gt;年初的时候用微信读书读了几本书，但是后续没有坚持下去；年末的时候买了《计算》，抽空读了一小部分，感觉还是跳着读自己感兴趣的部分比较合适&lt;/li&gt;
&lt;li&gt;重新开始学习日语（虽然之前硬背的五十音基本已经完全忘光了）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术 &amp;amp; 开源活动 &amp;amp; 探索
&lt;ul&gt;
&lt;li&gt;工作中实际使用的技术（后端 C++ / Node.js + TypeScript，前端 Vue，数据处理 Python / SQL）基本保持同等水平，C++ 可能是稍微了解的多了一些&lt;/li&gt;
&lt;li&gt;手里的几个开源项目依然处于维护状态，没怎么写新的（除了年底的 &lt;a href=&#34;https://github.com/jerrylususu/mainonly/tree/main&#34;&gt;mainonly&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;参加了一次国内的 Linux 中国活动，感觉大家都还挺害羞的，主题还有点意思但是运气不好没抽到奖&lt;/li&gt;
&lt;li&gt;探索各类 AIGC 工具，目前来看处于初步成熟阶段，可以做些事情但是能做的依然不太多
&lt;ul&gt;
&lt;li&gt;GPT：因为价格和付费渠道问题主要用 API，日常 3.5 基本够用，不行的话再上 4-turbo；如果只是问代码问题的话 Github Copliot 的体验更好，响应也更快（虽然 $10/月 也不算便宜就是了）；至少编写一些基本代码，或者处理某些特定疑难点已经很够用了&lt;/li&gt;
&lt;li&gt;其他 LLM：通过 OpenRouter 试用了 Claude / Gemini / Mixtral 的 API；Claude 对于长文很好用但是最近启用了 geoblocking 没法用；Gemini 用字符数计费有些神奇但是用起来和 3.5 感觉差不多；但是 GPT 效果实在是太好，用其他模型的意义不大；还试用了一些国内的 LLM，如智浦的 GLM 系列，百川的 Baichuan 系列，对于中文来说体验更好，另外因为词库以中文为主收费也更低&lt;/li&gt;
&lt;li&gt;SD/MD：MD 类用自然语言就可以出很惊人的效果；SD 自由度很好但是上手比较难，估计得熟读各种咒语 + 自己有足够多的时间体验&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;展望-2024&#34;&gt;展望 2024&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工作
&lt;ul&gt;
&lt;li&gt;正常升级 + 不出事故，至少先活过入职两年的分界线&lt;/li&gt;
&lt;li&gt;需要开始了解市场状态，重新开始面试准备了，至少万一被优化还有备选&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生活
&lt;ul&gt;
&lt;li&gt;回暖之后可以坚持运动；体重降回正常范围&lt;/li&gt;
&lt;li&gt;每个季度读一本工作无关的书&lt;/li&gt;
&lt;li&gt;学习日语到N2水平&lt;/li&gt;
&lt;li&gt;考过软考&lt;/li&gt;
&lt;li&gt;投资学习 &amp;amp; 实践：阅读相关书籍，尝试用收入的 10% 进行一些多元的投资操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术 &amp;amp; 开源 &amp;amp; 探索
&lt;ul&gt;
&lt;li&gt;了解和学习之前没接触过的技术：React / Vue 3 / Next.js / SSR&lt;/li&gt;
&lt;li&gt;用 Rust / Zig 写些小项目&lt;/li&gt;
&lt;li&gt;把五十音工具改造成微信小程序&lt;/li&gt;
&lt;li&gt;对图像生成类工具有更多了解（至少玩起来）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>多语言的 Hugo 博客</title>
      <link>https://nekonull.me/share/hugo-multilang/</link>
      <pubDate>Sat, 04 Nov 2023 20:27:43 +0800</pubDate>
      
      <guid>https://nekonull.me/share/hugo-multilang/</guid>
      <description>&lt;p&gt;之前看到了某位同学的分享，提到他在将博客多语言化之后，访问量有了显著的上升，于是也想试试看。在 OpenAI 的加持下文章翻译并不是什么难事，但是想要给一个现存的 Hugo 站点增加多语言支持依然不轻松。虽然 Hugo 本身自带了多语言支持的基本特性（&lt;a href=&#34;https://gohugo.io/content-management/multilingual/&#34;&gt;文档：Hugo Multilingual&lt;/a&gt;），但是倘若选用的主题不支持，则还需要对主题进行改造。&lt;/p&gt;
&lt;p&gt;目前对本博客，我选择了&amp;quot;按文件名翻译&amp;quot;的做法，从文档来看这似乎是对现有文件结构侵入最小的方案。简单来说，如果你的博客 Markdown 文件位于 &lt;code&gt;/content/blog.md&lt;/code&gt;，在同层级下新建一个 &lt;code&gt;blog.en.md&lt;/code&gt; 即可补充英文翻译。完成后可以通过在域名后补充 &lt;code&gt;/en/&lt;/code&gt; 路径的方式来访问。（主语言，在我这里是&amp;quot;简体中文&amp;quot;的路径不受影响，即无需补充语言后缀。）然而让用户手动补充语言路由显然是不可接受的，于是得在页面某处加一个语言选择器。这里我暂时加到了顶部。然后你的多语言博客就可以上线了。&lt;/p&gt;
&lt;p&gt;目前已知还存在的一些问题，待之后有空再来慢慢解决吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各种导航（例如左上角的后退）会回到站点根目录（也就是简体中文主页）；合理的做法是回到当前语言的对应主页&lt;/li&gt;
&lt;li&gt;RSS feed 链接有问题，默认提供的仍然是主语言的 RSS 链接，英文的链接在 &lt;code&gt;/en/&lt;/code&gt; 路径下；这里可能要考虑一个整合的 RSS？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大部分的核心多语言代码可以从这个 commit 看到：&lt;a href=&#34;https://github.com/jerrylususu/jerrylususu.github.io/pull/27/commits/ca7a83d6750f1f3d940a92b95b2179f793d26dd4&#34;&gt;ca7a83d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://discourse.gohugo.io/t/language-switcher-in-menu/11570&#34;&gt;Language switcher in menu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.regisphilibert.com/blog/2018/08/hugo-multilingual-part-1-managing-content-translation/&#34;&gt;Hugo Multilingual Part 1: Content translation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>我的 AI Prompt</title>
      <link>https://nekonull.me/share/my-ai-prompts/</link>
      <pubDate>Sun, 29 Oct 2023 20:17:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/my-ai-prompts/</guid>
      <description>&lt;p&gt;记录下自己自用的一些 Prompt。只是迭代下来感觉还不错，但不一定是最好的。如有推荐欢迎回复补充。&lt;/p&gt;
&lt;h2 id=&#34;通用场景&#34;&gt;通用场景&lt;/h2&gt;
&lt;p&gt;（主要配合 GPT-3.5-Turbo 使用，回答代码类问题）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;You are a helpful assistant and also a professional &amp;amp; experienced developer. You can help me by answering my questions. You can also ask me questions. If you are given code related questions, please answer in a consise manner, give code examples with less explaination.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;摘要总结英文&#34;&gt;摘要总结（英文）&lt;/h2&gt;
&lt;p&gt;（主要配合 claude-instant-v1 使用，用于文章摘要、结构化总结）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;You are a professional reader and analyst. Please summarize the following article in a organized manner. Use markdown list format with indentation indicating the layering of ideas. Ignore any text that is unrelated to the main article. Also include a short tl;dr summary (no more than 50 words and 3 sentences). Refer to the following example when summarizing.

---
[Example Output]

TL;DR summary: Summary in no more than 50 words.

# Title
## Heading 1
- Idea 1
    - Reason 1

## Heading 2
1. Numbered Item 1
2. Numbered Item 2

## Conclusion
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;摘要总结中文&#34;&gt;摘要总结（中文）&lt;/h2&gt;
&lt;p&gt;（主要配合 ChatGLM-Turbo 使用，用于文章摘要）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;您是一名专业的读者和分析者，现在请对下面的文章进行整理总结。使用Markdown列表格式输出总结，每个列表项是一个想法，并用缩进表示思想的层次，更深层的列表项代表论据或想法的演进，忽略任何与主文无关的文字。
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>用 mitmproxy 让 ChatGLM 适配 OpenAI 接口</title>
      <link>https://nekonull.me/share/try-chatglm/</link>
      <pubDate>Sun, 29 Oct 2023 19:41:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/try-chatglm/</guid>
      <description>&lt;p&gt;最近看到了几篇关于智谱 AI 的推送文章，才想起来他们的大模型（ChatGLM 系）已经上线好久了。回想 6B 模型刚公布的那会还在 AutoDL 上自己跑过，不过因为模型本身太小，所以其实能做的并不算多。注册了个开发者账户看了看文档，目前可以广泛使用的是 &lt;a href=&#34;https://open.bigmodel.cn/pricing&#34;&gt;ChatGLM-Turbo&lt;/a&gt;，上下文窗口 32k token，定价 0.005 元/千token，还是很便宜的。更不用说因为 GLM 系模型以中文语料为主，所以同等长度的中文文本，用 GLM 的 token 消耗比用 GPT 系列的 token 消耗会小很多（测试下来大概在 4x 左右）。&lt;/p&gt;
&lt;p&gt;官网的 Playground 玩了一会感觉还不错，生成的中文明显感觉更自然，没有 GPT 系那么浓烈的翻译腔，于是想着怎么接入到我自己用的客户端 &lt;a href=&#34;https://github.com/Bin-Huang/chatbox&#34;&gt;Chatbox&lt;/a&gt; 中日常使用。Chatbox 有内置的 ChatGLM 支持，一般直接设置下 token 就可以了。但是因为我主要用的还是 GPT 系模型，而 Chatbox 又只能全局设置一个 API 服务器字段，所以如果要同时使用 GPT 和 ChatGLM 的话，还是得用之前提到的 mitmproxy，手动完成请求的中转（没有什么是加一个抽象层不能解决的）。这里用 mitm 方式让 GLM 适配 GPT 接口还有个额外的好处，那就是只支持 OpenAI 的第三方应用也可以自动支持 GLM 了（虽然我还没这么用过）。&lt;/p&gt;
&lt;p&gt;和之前适配 OpenRouter 不一样，这次除了修改请求头，还要修改 SSE 响应体。不知道出于什么考虑，GLM 系列模型的响应事件和 GPT 系列的完全不同，修改起来还是有些复杂的。但总之调试了几个小时之后总算是改完了，代码在此：(不建议在生产环境使用，后果自负)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gist.github.com/jerrylususu/3ebcf6262d110da89ce58d1e8d55bc22&#34;&gt;https://gist.github.com/jerrylususu/3ebcf6262d110da89ce58d1e8d55bc22&lt;/a&gt;&lt;/p&gt;
&lt;script src=&#34;https://gist.github.com/jerrylususu/3ebcf6262d110da89ce58d1e8d55bc22.js&#34;&gt;&lt;/script&gt;
&lt;p&gt;改请求头比较简单，修改如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;换 host 和 path&lt;/li&gt;
&lt;li&gt;换 Authorization 头：参考 GLM 开发文档的&amp;quot;鉴权&amp;quot;一节即可（注意这里要用 &lt;code&gt;PyJWT&lt;/code&gt; 库，直接二进制安装的 &lt;code&gt;mitmproxy&lt;/code&gt; 带的 Python 环境不支持安装包，需要走 &lt;code&gt;pipx&lt;/code&gt; 安装，可参考&lt;a href=&#34;https://docs.mitmproxy.org/stable/overview-installation/#installation-from-the-python-package-index-pypi&#34;&gt;官方文档&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;消息列表（&lt;code&gt;messages&lt;/code&gt;）修改：GLM 系里叫做 &lt;code&gt;prompt&lt;/code&gt;，而且根据实测只能支持 &lt;code&gt;user&lt;/code&gt;-&lt;code&gt;assistant&lt;/code&gt; 交替，如果存在 &lt;code&gt;system&lt;/code&gt; 或是有两个连续的 &lt;code&gt;user&lt;/code&gt; 消息都会报错；这里稍微转换了下，把所有的非 &lt;code&gt;user&lt;/code&gt;/&lt;code&gt;assistant&lt;/code&gt; 消息都转成 &lt;code&gt;user&lt;/code&gt;，然后手动连接下连续的同 role 消息，保证最后构造的消息列表是两个角色交替。&lt;/li&gt;
&lt;li&gt;开启增量返回：默认似乎是全量返回，这里和 OpenAI 对齐，也改成增量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比较烦人的是改响应体，如下所示分别是 GLM 系的返回和 GPT 系的返回。可以发现 GLM 系列比较简单，只有事件类型、流 ID 和增量数据；GPT 系列就更复杂一些，返回的是个 JSON，里面还有嵌套结构。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# GLM&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;event:add&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;id:8065135252561182716&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;data:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\xef\xbc\x8c\n\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# GPT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data: {&amp;#34;id&amp;#34;: &amp;#34;chatcmpl-8EymH9k9DS9iQQvIH3BguHaZqmib9&amp;#34;, &amp;#34;object&amp;#34;: &amp;#34;chat.completion.chunk&amp;#34;, &amp;#34;created&amp;#34;: 1698580913, &amp;#34;model&amp;#34;: &amp;#34;gpt-3.5-turbo-0613&amp;#34;, &amp;#34;choices&amp;#34;: [{&amp;#34;index&amp;#34;: 0, &amp;#34;delta&amp;#34;: {&amp;#34;content&amp;#34;: &amp;#34;?&amp;#34;}, &amp;#34;finish_reason&amp;#34;: null}]}&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的改造思路其实很明确，先解析 GLM 的响应体，再据此拼装成 GPT 的相应格式，然后返回给应用就可以了，然而具体做起来还是有不少坑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一开始想的是直接 decode 之后分行解析，后来发现不太确定是信道问题还是服务器问题，有的时候接收到的 SSE 事件只有一半（导致 utf-8 decode 失败），或者是两个事件被合并成了一个事件（一个 SSE data 里面有两个 add 事件）。用国内的术语来说这个算粘包？为了解决这个问题，先把行解析改成了正则解析，然后用补充了一个 buffer，如果发现这次的事件不完整就先扔 buffer 里，等下一个事件凑齐了再一起解析。&lt;/li&gt;
&lt;li&gt;改完发现可以正常显示回复了，但是一直不能结束。还需要参考 OpenAI 的响应，额外补充 &lt;code&gt;DONE&lt;/code&gt; 事件。&lt;/li&gt;
&lt;li&gt;这样改完倒是基本能用了，但接下来发现还是不太对劲，生成代码的时候会多一个空格。这里看了响应数据，返回响应的确如此，于是在 data 开头两个空格的时候手动删掉一个。&lt;/li&gt;
&lt;li&gt;然后发现生成 markdown 列表的时候换行消失了。查响应发现有时会有多个 &lt;code&gt;data:&lt;/code&gt;，需要每个都处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前的效果算是初步可用了吧，但是偶尔如果响应本身不完整（例如某个 SSE 事件返回了不完整的 utf8 编码字符串，下一个事件没有包含丢失的数据），那就会直接报错。不过考虑到实际频率比较低，重试的成本比较小，这里还算可以接受吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 mitmproxy 重定向 OpenAI 请求到 OpenRouter</title>
      <link>https://nekonull.me/share/openrouter-mitmproxy/</link>
      <pubDate>Sun, 22 Oct 2023 20:55:00 +0800</pubDate>
      
      <guid>https://nekonull.me/share/openrouter-mitmproxy/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近在尝试使用一些基于 GPT 开发的工具，但遇到了一些网络相关的小问题。因为支付方式的限制，我自己并没有 OpenAI 的账户，实际使用的 API 是其他中间商（aka 二道贩子）转卖而来的， &lt;a href=&#34;https://openrouter.ai/docs#models&#34;&gt;OpenRouter&lt;/a&gt; 就是其中一家。（实际上 OpenRouter 做的还更多一些，更像是 LLM 的聚合提供商，除了 OpenAI 也有其他家的 LLM，如 Claude 或是 LLama。）但是很多开源工具并未考虑到这种情况，基本上都是假定用户使用的就是 OpenAI 的官方 API 端点，所以很多时候并不能直接使用各类预先构建好的产物（例如 docker 镜像），而是得把源码 clone 下来，找到 &lt;code&gt;import openai&lt;/code&gt; 或者是类似的调用发起位置，再在附近补充一些参数才能正常使用。手动改代码固然不是不行，但是总归还是有些繁琐，出问题的时候还额外增加了一个需要排查的环节。&lt;/p&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;有没有更好的，更自动化的方式，例如在网络上加个代理层，在第三方工具无需修改的前提下，就可以将 OpenAI 的请求转换成 OpenRouter 的请求呢？&lt;/p&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;p&gt;那既然都写到这里了，当然是有的。这里的核心是一个 man-in-the-middle （mitm / 中间人）代理，在请求到达代理的时候，修改请求中的内容，使之符合我们的要求，之后再继续对外发送就可以了。&lt;a href=&#34;https://mitmproxy.org/&#34;&gt;mitmproxy&lt;/a&gt; 就是这样一个工具。当然它的功能远不止修改请求，在完善的 Python API 的加成下还能做很多其他的事。（同类的工具其他工具，如 Fiddler，应该也能实现，但方法就需要给位自行探索了。）以下就是实现本次需求的核心代码，应该不需要太多解释。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; json
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; mitmproxy &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; http
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;request&lt;/span&gt;(flow: http&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;HTTPFlow) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 只处理 HOST 为 api.openai.com，且请求体为 JSON 的 POST 请求&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;host &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;api.openai.com&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;method &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;POST&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;headers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;content-type&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;startswith(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;application/json&amp;#34;&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;host &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;openrouter.ai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/api/v1/chat/completions&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;headers[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;authorization&amp;#34;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bearer sk-xxxxxxxxxx&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# token&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;headers[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http-referer&amp;#34;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://localhost:8080/my_great_app&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 应用标识&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            request_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_text())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 甚至可以在这里切换模型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# request_data[&amp;#34;model&amp;#34;] = &amp;#34;anthropic/claude-instant-v1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_text(json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dumps(request_data))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;JSONDecodeError:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 需要声明回包支持 stream，否则会等待全部数据到达再返回给应用，无法实现 LLM 打字效果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;responseheaders&lt;/span&gt;(flow):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    flow&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;启动 mitmproxy 时需要带上 Python 脚本参数，以及如果有上游代理则需要再声明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mitmweb --mode upstream:http://{upstream_addr} -s openrouter.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动后会弹出 mitmproxy 的网页控制台，这时候就用第三方工具发请求试试了，一切顺利的话可以看到结果正常返回且网页上显示请求数据。如果出现问题也可以看命令行窗口的输出。如果第三方工具本身支持设置应用内代理（如 &lt;a href=&#34;https://github.com/Bin-Huang/chatbox&#34;&gt;Chatbox&lt;/a&gt;）则最理想；不支持的话可以考虑设置系统代理、用 mitmproxy 的&lt;a href=&#34;https://docs.mitmproxy.org/stable/howto-transparent/&#34;&gt;透明代理模式&lt;/a&gt;、或者用 &lt;a href=&#34;https://www.proxifier.com/&#34;&gt;Proxifer&lt;/a&gt; 这类工具来强制应用代理。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
