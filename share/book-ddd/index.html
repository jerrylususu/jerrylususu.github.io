<!DOCTYPE html>
<html lang="zh">
	<head>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="generator" content="Hugo 0.145.0">
	<title>读书记录《悟道领域驱动设计》 - Nekonull&#39;s Garden</title>

	<meta name="description" content="
ch2 应用架构

贫血模型 vs 充血模型

贫血模型：类只是数据容器，没有行为（例如 pojo）
充血模型：类有属性（数据），也有方法（行为）


项目结构

接口层：对外暴露api/消息consumer
应用服务层：协调领域模型完成业务逻辑
基础设施层：写db/缓存/调外部服务
领域层：领域内的具体逻辑


查询的两种实现

1 读数据后加载领域模型（聚合根），聚合根转换为查询结果 view
2 直接用实际存储的数据模型，跳过领域对象加载，直接用把数据模型转换为查询结果 view




ch3 实体和值对象

实体：有唯一标识的领域模型

e.g. 内容发布系统的文章


值对象：没有唯一标识，需要的时候随时构造，值一样就认为是相同的对象

e.g. 内容发布系统的文章标题
DP：Domain Primitive 领域内的基本数据类型，值对象的一种

e.g. 金融系统中的金额（money）






ch4 聚合与聚合根

聚合：一组对象组成的对象树

单个实体也是聚合
聚合是一致性的边界；聚合内强一致，跨聚合最终一致

一个事务只更新单个聚合




聚合根：这个对象树的入口

单个实体也可以是聚合根
外部对象只能引用聚合根（通常通过持有一个id）


拆分聚合

一个实体被多个聚合根引用，应该被提升为聚合根
1:N 的集合属性（Role-Resource Binding），因为存在双向查找的需要（Role找Resource，Resource找Role），通常也可能被提升为聚合根




ch5 Factory, Repo, 领域服务

Factory：从无到有创建领域对象

需要分配 id
通常用 builder 模式


Repo：保存和加载聚合根，和实际的存储解耦

save：聚合根持久化到数据库

注意事务控制，所有实际的写操作应该在一个事务内执行（例如文章写一个表，文章内容写另一个表）


load：从数据库查询数据对象，组装回聚合根
推荐实现行级 repo，一个聚合根对应数据库中一行数据

如果存在查多行的需求，如 queryList，应该用 CQRS 分离出去




领域服务：包含领域中不适合放在实体/值对象的业务操作，应该是无状态的

例子：导出数据为 excel




ch6 设计模式

责任链：多个handler逐个执行
策略：从多种算法实现中选择一个（根据业务类型匹配到策略）
桥接
规约：验证复杂规则


ch7 防腐层 ACL

避免外部系统变更影响到当前系统（字段名变化、包名变化&hellip;）
实现：适配器模式

出入参数应该是本地值对象，或者基本数据类型
外部异常/错误码应该转换为本地异常/错误码
只返回实际需要的字段
一般在应用服务/领域服务调用防腐层，不要在实体和值对象使用




ch8 领域事件

幂等实现：数据库唯一索引 /  状态机
事件建模：用领域语言（例如账户被激活）；建模为值对象/贫血对象（不可变的）
应用

触发其他领域/聚合的行为
记录状态变化


事件消息体：实体id，事件id，事件类型，发生事件

也可选包含具体数据，减少查询需要，例如用户变更手机号事件带上新的手机号


生成事件

应用层创建：推荐，直接在应用层生成，然后调用基础服务发布
聚合根创建：聚合根内生成事件，存储在聚合根内一个临时位置，应用层调用方法从聚合根取得，然后调用基础服务进行发布


发布事件

问题：保存聚合根和发布领域事件应该是一个事务，不能一个失败一个成功；但是引入分布式事务会造成复杂度上升
解决：用一个db里事件表，repo save的时候不仅写聚合根，还写事件表；然后用事件表变更触发mq

轮询补偿：一个外部定时任务，检查事件表中状态=未发布的事件，读出来发mq，然后更新状态为已发布
拖尾：用一个db拖尾组件监听db变更，自动发布到mq




订阅事件：事件 consumer 作为一个新的接口层，调用应用层服务

注意幂等




ch9 CQRS

问题：查询的时候加载聚合根可能没必要（例如只读取一部分字段）；但是修改的时候必须要加载完整聚合根
CQRS 应用层分为 查询 query 和 修改 command 两部分，分别用不同的模型处理

command 依然加载完整聚合根
query 直接用数据模型（db数据）进行查询，转换为需要的返回 view


实现

同数据源：比较简单，query 不用 repo.load 而是直接读db
异数据源：复杂，可能导致不一致

需求：主数据存储 mysql，用 es 做文本搜索
实现：应用层发布领域事件，db日志拖尾
查询可以是一个贫血模型，因为没有复杂逻辑且只读数据不修改




缺点：复杂度高、可能导致数据一致性问题、增加学习成本


ch10 事件溯源

想法：存储领域事件，读取时通过重放领域事件得到最新聚合状态

优点：完整业务跟踪能力；可以回滚到任意时刻的聚合根


实现1：最原始的实现，直接存领域事件，读时回放

只有一个事件表


实现2：事件多查起来慢，因此加快照，回放时用 上次快照 &#43; 上次快照后的事件

事件表 &#43; 快照表，save的时候可能需要生成快照


实现3：快照表用拉链表实现，存储所有事件&#43;聚合根所有版本（含有效期）

拉链表：含有开始时间和结束时间，表明这一行数据在此时间段内有效




ch11 一致性

聚合内一致性

事务应该在 repo 实现，不应该在应用层实现，否则会造成事务过大
用乐观锁避免并发更新问题
repo save 失败，需要在应用层重试，来确保聚合数据是最新状态（即重新 load）

因为会重新调用外部接口，依赖的外部接口应该幂等
不适合频繁更新的热点数据（可能导致频繁重试）
重试次数规划好，一般一次就够了，多次的话应该考虑其他架构
重试次数/触发原因可配置，一般只有乐观锁失败再重试，其他错误不应该重试


读写性能问题

一般业务做不到那么大
读多写少：读写分离、缓存、复杂查询维护单独的读数据源、分库分表
写之前的确需要完整加载聚合，写慢点就忍吧




跨聚合一致性：实际上是分布式事务

二阶段提交：prepare, commit；commit 可能失败，此时rollback

代价比较大


本地消息表&#43;发布领域事件：见 ch8
最大努力通知：上游不断发起通知调用给下游，直到下游确认

适用于对可靠性要求不高
发起者需要提供查单接口，供接收者主动查询状态
发起者需要实现重复通知，接收者自己保证幂等
发通知间隔应该指数退避，且限制最大次数，避免无限发送


TCC：try, confirm, cancel；try成功了confirm必须成功

注意点1 幂等：confirm/cancel幂等
注意点2 空回滚：没有调用try就调用了cancel；收到cancel查资源状态，没try过应该直接返回
注意点3 事务悬挂：先执行cancel再执行try；收到try查资源状态，被cancel过也直接返回


saga：正向perform，补偿compensate

注意点1 隔离性：正向操作完成后，其他事务已经能观察到了，负向回滚之后可能影响到其他事务（用户看到订单消失）

考虑引入一个中间状态例如 pending


注意点2 幂等：perform/compensate 都应该幂等
注意点3 空回滚：没有perform就compensate；补偿前用业务主键查是否有perform，没有直接返回，并记录已回滚
注意点4 事务悬挂：先compensate再perform；perform前查询是否compensate过，有则报错


选型

不要求实时，只要求最终一致：本地消息表、最大努力通知
要求实时：TCC
长事务、涉及外部/遗留系统：saga






ch12 战略设计

概念

限界上下文：一个特定业务内的概念、规则、流程

如电商系统中的订单、商品、营销、物流


上下文映射：不同限界上下文之间的协作关系
子域：关联性强的限界上下文形成的大的业务概念

主播&#43;直播 -&gt; 视频直播子域




划分限界上下文：按照业务边界
上下文映射

共享内核：存在共享的代码、领域模型、基础设施等
客户 供应商：客户（下游）给供应商（上游）提要求，如加接口、加字段
跟随者：上游不响应下游要求，下游得自己做
各行其道：上下游完全不关联


子域类型

核心子域：业务系统最重要的部分，业务价值高
支撑子域：起到支撑作用，但是没有成熟/通用方案，需要自己构建
通用子域：有通用性，存在成熟/通用方案，可以通过采购/开源获得




ch13 领域建模

事件风暴法：收集所有领域事件，归纳领域模型
收集内容

领域事件
命令：触发领域事件
actor：命令的人为发起者
策略：命令的规则发起者，满足某种条件自动触发；定时任务也算
外部系统：也是命令的发起者
聚合
读模型：actor 发起命令前读的数据（例如审核员查看内容），需要这些数据辅助决策
热点：待定问题


建模流程

列举领域事件
按业务流程排序领域事件；无法连接的说明可能遗漏了
补充命令
补充发起者
提取聚合：同一个聚合的领域事件归类到一起
补充读模型
划分限界上下文，标注映射关系；注意需要标记上下游
划分子域




ch14 研发效能

maven 脚手架
响应封装 graceful response
对象转换 mapstruct
静态分析
低代码
持续集成/持续交付/持续部署


ch15 测试驱动开发 tdd

红绿循环：写测试、测试失败、写代码、测试通过、重构、测试通过
贫血模式的 tdd

dao：生成的，一般不用测
service：对基础设施的调用应该 mock
controller：mockmvc 直接测试 http 请求，验证响应（如返回码）


ddd 中的 tdd

实体：测全分支；不应该依赖启动容器和基础设施
值对象：覆盖业务规则
factory




ch16 敏捷开发

scrum
看板


ch17 架构可视化

c4 模型

系统上下文图：只展示核心系统、支持元素（如外部依赖、用户）
容器图：展示主要数据选型和个容器的职责分工

容器：可独立运行/部署的单元（如后台单体、缓存、数据库）


组件图：展示可执行容器内部分工，指导开发
代码图：UML/ER图，不推荐画（变更频繁）


其他图

系统全景图：展示关联的所有系统
动态图：展示元素在运行时如何协作，用箭头和编号表示顺序
部署图：说明部署方案，含有实例数量、机房等




ch18 重构

模式

修缮者：实现新方法，保留老方法，用开关切换，无问题后删除老方法
绞杀者：设计新系统，用一个门面承接流量，逐渐在新系统实现功能，并切老系统的流量到新系统，直到老系统完全无流量
推翻重建：彻底放弃老系统


流程

启动

必要性评估：考虑性能、可靠性、技术栈、业务支持、研发效率、运营效率
环境因素：企业战略、组织架构稳定性、文化氛围、管理风格
效益和风险分析
可行性分析：天时（和企业战略一致）、地利（已具备环境条件）、人和（团队愿意支持思想一致）
干系人识别：团队成员、管理者、职能部门负责人、最终用户


规划

确认重构范围
工作任务分解：任务分给唯一的某个人完成，可以向其他组员寻求帮助，但是负责人只有一个
工期估算和进度计划
沟通计划：管理层、项目成员、外部团队
人力资源计划：人力不足需要申请人力、提前培训
质量管理计划：业务流程梳理用力、数据一致性对比


执行

组建团队
梳理现有业务逻辑：读代码、读历史文档、头脑风暴
整理用例并评审
实施开发：DDD、敏捷、测试驱动、CICD
数据迁移
灰度切量
老系统下线：老系统可能还有调用者


监控

进度
质量
待办项


收尾

沉淀过程资产：架构图、FAQ、接口文档
推动新系统普及：通知调用方




数据迁移的实现

方案1：双写

步骤1：老系统开始写入新数据源；新系统需要支持写老数据源
步骤2：历史数据从老数据源全量迁移到新数据源；检查新老数据一致性
步骤3：读验证，灰度部分读流量到新系统
步骤4：写验证，灰度部分写流量到新系统（新系统依然写老数据源，且定期校验）
步骤5：全部流量切换到新系统，新系统双写老数据源
步骤6：新系统稳定后，关闭新系统写老数据源开关，老系统下线


方案2：双向数据同步

正向：老-&gt;新：传输老系统的所有数据
反向：新-&gt;老：只传输新系统生成的数据（对来自老系统的数据有特殊标记）
步骤：正向链路一直打开，全量数据从老系统迁移到新系统，且保证增量同步；写验证前打开反向链路，直到老系统下线






ch19 布道领域驱动设计

编码指南


">


	
	
	




<link rel="stylesheet" href="/css/ui.css">

	
	

	<script defer src="/js/dark-mode.js"></script>
	<link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">
	<link  rel="stylesheet" href="/css/dropdown.css">

	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3973436778637330"
	crossorigin="anonymous"></script>

	<link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">
	
				
	
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-R01JLDY2KE"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-R01JLDY2KE');
        }
      </script>
</head>

<body>
<header class="container no-print">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li><li><img class="icon-text" id="dark-mode-toggle" src="/img/moon-regular.svg" alt="Toggle Dark Mode"></a></li><li><a href="/til">TIL</a></li><li><a href="/about">关于</a></li><li><a href="/archive">存档</a></li><li><a href="/tags">标签</a></li><li><a href="/share">短文</a></li><li><a href="/posts">长文</a></li><li><a href="/project">项目</a></li>
<li id="language-switch" class="dropdown">
<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"><img class="icon-text" src="/img/translate.svg" alt="Select Language"/></a>
<ul class="dropdown-menu">
  
  
  
      
      
          
      
          
            
            
                <li><a href="https://nekonull.me/share/book-ddd/" class="active langselect">简体中文</a></li>
            
          
      
  
</ul>






	</ul>
</nav>

	</div>
</header>
<main class="container">

<article>
	<header><hgroup id="brand">
	<h1>读书记录《悟道领域驱动设计》</h1>
	<h5>
		
		<time datetime="2025-01-05 23:38:12 &#43;0800 &#43;0800">2025/01/05</time>
		<span class="no-print">
			-
				
				<a href="/tags/%e9%98%85%e8%af%bb">阅读</a>
				<span>
	</h5>
	
</hgroup>
<hr class="sep" />
</header>
	<ul>
<li>ch2 应用架构
<ul>
<li>贫血模型 vs 充血模型
<ul>
<li>贫血模型：类只是数据容器，没有行为（例如 pojo）</li>
<li>充血模型：类有属性（数据），也有方法（行为）</li>
</ul>
</li>
<li>项目结构
<ul>
<li>接口层：对外暴露api/消息consumer</li>
<li>应用服务层：协调领域模型完成业务逻辑</li>
<li>基础设施层：写db/缓存/调外部服务</li>
<li>领域层：领域内的具体逻辑</li>
</ul>
</li>
<li>查询的两种实现
<ul>
<li>1 读数据后加载领域模型（聚合根），聚合根转换为查询结果 view</li>
<li>2 直接用实际存储的数据模型，跳过领域对象加载，直接用把数据模型转换为查询结果 view</li>
</ul>
</li>
</ul>
</li>
<li>ch3 实体和值对象
<ul>
<li>实体：有唯一标识的领域模型
<ul>
<li>e.g. 内容发布系统的文章</li>
</ul>
</li>
<li>值对象：没有唯一标识，需要的时候随时构造，值一样就认为是相同的对象
<ul>
<li>e.g. 内容发布系统的文章标题</li>
<li>DP：Domain Primitive 领域内的基本数据类型，值对象的一种
<ul>
<li>e.g. 金融系统中的金额（money）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ch4 聚合与聚合根
<ul>
<li>聚合：一组对象组成的对象树
<ul>
<li>单个实体也是聚合</li>
<li>聚合是一致性的边界；聚合内强一致，跨聚合最终一致
<ul>
<li>一个事务只更新单个聚合</li>
</ul>
</li>
</ul>
</li>
<li>聚合根：这个对象树的入口
<ul>
<li>单个实体也可以是聚合根</li>
<li>外部对象只能引用聚合根（通常通过持有一个id）</li>
</ul>
</li>
<li>拆分聚合
<ul>
<li>一个实体被多个聚合根引用，应该被提升为聚合根</li>
<li>1:N 的集合属性（Role-Resource Binding），因为存在双向查找的需要（Role找Resource，Resource找Role），通常也可能被提升为聚合根</li>
</ul>
</li>
</ul>
</li>
<li>ch5 Factory, Repo, 领域服务
<ul>
<li>Factory：从无到有创建领域对象
<ul>
<li>需要分配 id</li>
<li>通常用 builder 模式</li>
</ul>
</li>
<li>Repo：保存和加载聚合根，和实际的存储解耦
<ul>
<li>save：聚合根持久化到数据库
<ul>
<li>注意事务控制，所有实际的写操作应该在一个事务内执行（例如文章写一个表，文章内容写另一个表）</li>
</ul>
</li>
<li>load：从数据库查询数据对象，组装回聚合根</li>
<li>推荐实现行级 repo，一个聚合根对应数据库中一行数据
<ul>
<li>如果存在查多行的需求，如 queryList，应该用 CQRS 分离出去</li>
</ul>
</li>
</ul>
</li>
<li>领域服务：包含领域中不适合放在实体/值对象的业务操作，应该是无状态的
<ul>
<li>例子：导出数据为 excel</li>
</ul>
</li>
</ul>
</li>
<li>ch6 设计模式
<ul>
<li>责任链：多个handler逐个执行</li>
<li>策略：从多种算法实现中选择一个（根据业务类型匹配到策略）</li>
<li>桥接</li>
<li>规约：验证复杂规则</li>
</ul>
</li>
<li>ch7 防腐层 ACL
<ul>
<li>避免外部系统变更影响到当前系统（字段名变化、包名变化&hellip;）</li>
<li>实现：适配器模式
<ul>
<li>出入参数应该是本地值对象，或者基本数据类型</li>
<li>外部异常/错误码应该转换为本地异常/错误码</li>
<li>只返回实际需要的字段</li>
<li>一般在应用服务/领域服务调用防腐层，不要在实体和值对象使用</li>
</ul>
</li>
</ul>
</li>
<li>ch8 领域事件
<ul>
<li>幂等实现：数据库唯一索引 /  状态机</li>
<li>事件建模：用领域语言（例如账户被激活）；建模为值对象/贫血对象（不可变的）</li>
<li>应用
<ul>
<li>触发其他领域/聚合的行为</li>
<li>记录状态变化</li>
</ul>
</li>
<li>事件消息体：实体id，事件id，事件类型，发生事件
<ul>
<li>也可选包含具体数据，减少查询需要，例如用户变更手机号事件带上新的手机号</li>
</ul>
</li>
<li>生成事件
<ul>
<li>应用层创建：推荐，直接在应用层生成，然后调用基础服务发布</li>
<li>聚合根创建：聚合根内生成事件，存储在聚合根内一个临时位置，应用层调用方法从聚合根取得，然后调用基础服务进行发布</li>
</ul>
</li>
<li>发布事件
<ul>
<li>问题：保存聚合根和发布领域事件应该是一个事务，不能一个失败一个成功；但是引入分布式事务会造成复杂度上升</li>
<li>解决：用一个db里事件表，repo save的时候不仅写聚合根，还写事件表；然后用事件表变更触发mq
<ul>
<li>轮询补偿：一个外部定时任务，检查事件表中状态=未发布的事件，读出来发mq，然后更新状态为已发布</li>
<li>拖尾：用一个db拖尾组件监听db变更，自动发布到mq</li>
</ul>
</li>
</ul>
</li>
<li>订阅事件：事件 consumer 作为一个新的接口层，调用应用层服务
<ul>
<li>注意幂等</li>
</ul>
</li>
</ul>
</li>
<li>ch9 CQRS
<ul>
<li>问题：查询的时候加载聚合根可能没必要（例如只读取一部分字段）；但是修改的时候必须要加载完整聚合根</li>
<li>CQRS 应用层分为 查询 query 和 修改 command 两部分，分别用不同的模型处理
<ul>
<li>command 依然加载完整聚合根</li>
<li>query 直接用数据模型（db数据）进行查询，转换为需要的返回 view</li>
</ul>
</li>
<li>实现
<ul>
<li>同数据源：比较简单，query 不用 repo.load 而是直接读db</li>
<li>异数据源：复杂，可能导致不一致
<ul>
<li>需求：主数据存储 mysql，用 es 做文本搜索</li>
<li>实现：应用层发布领域事件，db日志拖尾</li>
<li>查询可以是一个贫血模型，因为没有复杂逻辑且只读数据不修改</li>
</ul>
</li>
</ul>
</li>
<li>缺点：复杂度高、可能导致数据一致性问题、增加学习成本</li>
</ul>
</li>
<li>ch10 事件溯源
<ul>
<li>想法：存储领域事件，读取时通过重放领域事件得到最新聚合状态
<ul>
<li>优点：完整业务跟踪能力；可以回滚到任意时刻的聚合根</li>
</ul>
</li>
<li>实现1：最原始的实现，直接存领域事件，读时回放
<ul>
<li>只有一个事件表</li>
</ul>
</li>
<li>实现2：事件多查起来慢，因此加快照，回放时用 上次快照 + 上次快照后的事件
<ul>
<li>事件表 + 快照表，save的时候可能需要生成快照</li>
</ul>
</li>
<li>实现3：快照表用拉链表实现，存储所有事件+聚合根所有版本（含有效期）
<ul>
<li>拉链表：含有开始时间和结束时间，表明这一行数据在此时间段内有效</li>
</ul>
</li>
</ul>
</li>
<li>ch11 一致性
<ul>
<li>聚合内一致性
<ul>
<li>事务应该在 repo 实现，不应该在应用层实现，否则会造成事务过大</li>
<li>用乐观锁避免并发更新问题</li>
<li>repo save 失败，需要在应用层重试，来确保聚合数据是最新状态（即重新 load）
<ul>
<li>因为会重新调用外部接口，依赖的外部接口应该幂等</li>
<li>不适合频繁更新的热点数据（可能导致频繁重试）</li>
<li>重试次数规划好，一般一次就够了，多次的话应该考虑其他架构</li>
<li>重试次数/触发原因可配置，一般只有乐观锁失败再重试，其他错误不应该重试</li>
</ul>
</li>
<li>读写性能问题
<ul>
<li>一般业务做不到那么大</li>
<li>读多写少：读写分离、缓存、复杂查询维护单独的读数据源、分库分表</li>
<li>写之前的确需要完整加载聚合，写慢点就忍吧</li>
</ul>
</li>
</ul>
</li>
<li>跨聚合一致性：实际上是分布式事务
<ul>
<li>二阶段提交：prepare, commit；commit 可能失败，此时rollback
<ul>
<li>代价比较大</li>
</ul>
</li>
<li>本地消息表+发布领域事件：见 ch8</li>
<li>最大努力通知：上游不断发起通知调用给下游，直到下游确认
<ul>
<li>适用于对可靠性要求不高</li>
<li>发起者需要提供查单接口，供接收者主动查询状态</li>
<li>发起者需要实现重复通知，接收者自己保证幂等</li>
<li>发通知间隔应该指数退避，且限制最大次数，避免无限发送</li>
</ul>
</li>
<li>TCC：try, confirm, cancel；try成功了confirm必须成功
<ul>
<li>注意点1 幂等：confirm/cancel幂等</li>
<li>注意点2 空回滚：没有调用try就调用了cancel；收到cancel查资源状态，没try过应该直接返回</li>
<li>注意点3 事务悬挂：先执行cancel再执行try；收到try查资源状态，被cancel过也直接返回</li>
</ul>
</li>
<li>saga：正向perform，补偿compensate
<ul>
<li>注意点1 隔离性：正向操作完成后，其他事务已经能观察到了，负向回滚之后可能影响到其他事务（用户看到订单消失）
<ul>
<li>考虑引入一个中间状态例如 pending</li>
</ul>
</li>
<li>注意点2 幂等：perform/compensate 都应该幂等</li>
<li>注意点3 空回滚：没有perform就compensate；补偿前用业务主键查是否有perform，没有直接返回，并记录已回滚</li>
<li>注意点4 事务悬挂：先compensate再perform；perform前查询是否compensate过，有则报错</li>
</ul>
</li>
<li>选型
<ul>
<li>不要求实时，只要求最终一致：本地消息表、最大努力通知</li>
<li>要求实时：TCC</li>
<li>长事务、涉及外部/遗留系统：saga</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ch12 战略设计
<ul>
<li>概念
<ul>
<li>限界上下文：一个特定业务内的概念、规则、流程
<ul>
<li>如电商系统中的订单、商品、营销、物流</li>
</ul>
</li>
<li>上下文映射：不同限界上下文之间的协作关系</li>
<li>子域：关联性强的限界上下文形成的大的业务概念
<ul>
<li>主播+直播 -&gt; 视频直播子域</li>
</ul>
</li>
</ul>
</li>
<li>划分限界上下文：按照业务边界</li>
<li>上下文映射
<ul>
<li>共享内核：存在共享的代码、领域模型、基础设施等</li>
<li>客户 供应商：客户（下游）给供应商（上游）提要求，如加接口、加字段</li>
<li>跟随者：上游不响应下游要求，下游得自己做</li>
<li>各行其道：上下游完全不关联</li>
</ul>
</li>
<li>子域类型
<ul>
<li>核心子域：业务系统最重要的部分，业务价值高</li>
<li>支撑子域：起到支撑作用，但是没有成熟/通用方案，需要自己构建</li>
<li>通用子域：有通用性，存在成熟/通用方案，可以通过采购/开源获得</li>
</ul>
</li>
</ul>
</li>
<li>ch13 领域建模
<ul>
<li>事件风暴法：收集所有领域事件，归纳领域模型</li>
<li>收集内容
<ul>
<li>领域事件</li>
<li>命令：触发领域事件</li>
<li>actor：命令的人为发起者</li>
<li>策略：命令的规则发起者，满足某种条件自动触发；定时任务也算</li>
<li>外部系统：也是命令的发起者</li>
<li>聚合</li>
<li>读模型：actor 发起命令前读的数据（例如审核员查看内容），需要这些数据辅助决策</li>
<li>热点：待定问题</li>
</ul>
</li>
<li>建模流程
<ul>
<li>列举领域事件</li>
<li>按业务流程排序领域事件；无法连接的说明可能遗漏了</li>
<li>补充命令</li>
<li>补充发起者</li>
<li>提取聚合：同一个聚合的领域事件归类到一起</li>
<li>补充读模型</li>
<li>划分限界上下文，标注映射关系；注意需要标记上下游</li>
<li>划分子域</li>
</ul>
</li>
</ul>
</li>
<li>ch14 研发效能
<ul>
<li>maven 脚手架</li>
<li>响应封装 graceful response</li>
<li>对象转换 mapstruct</li>
<li>静态分析</li>
<li>低代码</li>
<li>持续集成/持续交付/持续部署</li>
</ul>
</li>
<li>ch15 测试驱动开发 tdd
<ul>
<li>红绿循环：写测试、测试失败、写代码、测试通过、重构、测试通过</li>
<li>贫血模式的 tdd
<ul>
<li>dao：生成的，一般不用测</li>
<li>service：对基础设施的调用应该 mock</li>
<li>controller：mockmvc 直接测试 http 请求，验证响应（如返回码）</li>
</ul>
</li>
<li>ddd 中的 tdd
<ul>
<li>实体：测全分支；不应该依赖启动容器和基础设施</li>
<li>值对象：覆盖业务规则</li>
<li>factory</li>
</ul>
</li>
</ul>
</li>
<li>ch16 敏捷开发
<ul>
<li>scrum</li>
<li>看板</li>
</ul>
</li>
<li>ch17 架构可视化
<ul>
<li>c4 模型
<ul>
<li>系统上下文图：只展示核心系统、支持元素（如外部依赖、用户）</li>
<li>容器图：展示主要数据选型和个容器的职责分工
<ul>
<li>容器：可独立运行/部署的单元（如后台单体、缓存、数据库）</li>
</ul>
</li>
<li>组件图：展示可执行容器内部分工，指导开发</li>
<li>代码图：UML/ER图，不推荐画（变更频繁）</li>
</ul>
</li>
<li>其他图
<ul>
<li>系统全景图：展示关联的所有系统</li>
<li>动态图：展示元素在运行时如何协作，用箭头和编号表示顺序</li>
<li>部署图：说明部署方案，含有实例数量、机房等</li>
</ul>
</li>
</ul>
</li>
<li>ch18 重构
<ul>
<li>模式
<ul>
<li>修缮者：实现新方法，保留老方法，用开关切换，无问题后删除老方法</li>
<li>绞杀者：设计新系统，用一个门面承接流量，逐渐在新系统实现功能，并切老系统的流量到新系统，直到老系统完全无流量</li>
<li>推翻重建：彻底放弃老系统</li>
</ul>
</li>
<li>流程
<ul>
<li>启动
<ul>
<li>必要性评估：考虑性能、可靠性、技术栈、业务支持、研发效率、运营效率</li>
<li>环境因素：企业战略、组织架构稳定性、文化氛围、管理风格</li>
<li>效益和风险分析</li>
<li>可行性分析：天时（和企业战略一致）、地利（已具备环境条件）、人和（团队愿意支持思想一致）</li>
<li>干系人识别：团队成员、管理者、职能部门负责人、最终用户</li>
</ul>
</li>
<li>规划
<ul>
<li>确认重构范围</li>
<li>工作任务分解：任务分给唯一的某个人完成，可以向其他组员寻求帮助，但是负责人只有一个</li>
<li>工期估算和进度计划</li>
<li>沟通计划：管理层、项目成员、外部团队</li>
<li>人力资源计划：人力不足需要申请人力、提前培训</li>
<li>质量管理计划：业务流程梳理用力、数据一致性对比</li>
</ul>
</li>
<li>执行
<ul>
<li>组建团队</li>
<li>梳理现有业务逻辑：读代码、读历史文档、头脑风暴</li>
<li>整理用例并评审</li>
<li>实施开发：DDD、敏捷、测试驱动、CICD</li>
<li>数据迁移</li>
<li>灰度切量</li>
<li>老系统下线：老系统可能还有调用者</li>
</ul>
</li>
<li>监控
<ul>
<li>进度</li>
<li>质量</li>
<li>待办项</li>
</ul>
</li>
<li>收尾
<ul>
<li>沉淀过程资产：架构图、FAQ、接口文档</li>
<li>推动新系统普及：通知调用方</li>
</ul>
</li>
</ul>
</li>
<li>数据迁移的实现
<ul>
<li>方案1：双写
<ul>
<li>步骤1：老系统开始写入新数据源；新系统需要支持写老数据源</li>
<li>步骤2：历史数据从老数据源全量迁移到新数据源；检查新老数据一致性</li>
<li>步骤3：读验证，灰度部分读流量到新系统</li>
<li>步骤4：写验证，灰度部分写流量到新系统（新系统依然写老数据源，且定期校验）</li>
<li>步骤5：全部流量切换到新系统，新系统双写老数据源</li>
<li>步骤6：新系统稳定后，关闭新系统写老数据源开关，老系统下线</li>
</ul>
</li>
<li>方案2：双向数据同步
<ul>
<li>正向：老-&gt;新：传输老系统的所有数据</li>
<li>反向：新-&gt;老：只传输新系统生成的数据（对来自老系统的数据有特殊标记）</li>
<li>步骤：正向链路一直打开，全量数据从老系统迁移到新系统，且保证增量同步；写验证前打开反向链路，直到老系统下线</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ch19 布道领域驱动设计
<ul>
<li>编码指南</li>
</ul>
</li>
</ul>

</article>
<nav class="no-print post-nav">

	<a class="prev-post" href="https://nekonull.me/share/gcc-constexpr-lambda-bug/">
		<img class="icon-text" src="/img/prev.svg"/>不要在 gcc 7 里隐式捕获 constexpr 数组</a>


	<a class="next-post" href="https://nekonull.me/share/game-a-short-hike/">游戏推荐 - A Short Hike<img class="icon-text" src="/img/next.svg"/>
	</a>

</nav>


<section id="related">
  <h4>另请参阅</h4>
  <ul>
    
  	<li><a href="/share/book-time-poverty/">读书记录《时间贫困》</a></li>
  	
  	<li><a href="/share/book-philosophy-software-design-2nd/">读书记录《软件设计的哲学（第2版）》</a></li>
  	
  </ul>
</section>




	
  <script
    src="https://giscus.app/client.js"
    data-repo="jerrylususu/jerrylususu.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxNDM1MTk3NDY="
    data-category="Blog Comments"
    data-category-id="DIC_kwDOCI3wAs4CZNcG"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-input-position="top"
    data-theme="preferred-color-scheme"
    data-lang="zh-CN"
    data-loading="lazy"
    data-strict="1"
    
    data-theme="preferred-color-scheme"
    crossorigin="anonymous"
    async
  ></script>

			<hr class="sep" />
		</main>
		<footer class="container no-print">
			<div class="u-footer">
				

<a href="https://github.com/jerrylususu/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>







				<p>
					
					使用的主题: <a href="https://github.com/yursan9/manis-hugo-theme">Manis</a><br>
					
					
					CC-BY-SA-4.0
					
					
				</p>
				
				<a href="#brand">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>回到顶部</span>
				</a>
				
			</div>
		</footer>
		
	</body>
</html>

