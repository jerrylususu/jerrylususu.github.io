<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TIL - Nekonull&#39;s Garden</title>
    <link>https://nekonull.me/</link>
    <description>Recent TIL (Today I Learned) content on Nekonull&#39;s Garden</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>CC-BY-SA-4.0</copyright>
    <lastBuildDate>Fri, 14 Mar 2025 13:45:33 +0000</lastBuildDate><atom:link href="https://nekonull.me/til.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Claude 的 Text Editor Tool</title>
      <link>https://nekonull.me/til/claude-text-editor-tool/</link>
      <pubDate>Fri, 14 Mar 2025 13:45:33 +0000</pubDate>
      
      <guid>https://nekonull.me/til/claude-text-editor-tool/</guid>
      <description>&lt;p&gt;Claude 最近新支持了一个特殊的工具：Text Editor Tool，本质上是一组预定义的接口，让 LLM 可以实现文本编辑（不过看起来更像是为了代码编辑准备的）。具体定义的接口有 view, create, str_replace, insert, undo_edit。&lt;/p&gt;
&lt;p&gt;文档里一些比较有趣的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;view 文件的时候，可以指定特定的 range（有助于处理特别大的文件）&lt;/li&gt;
&lt;li&gt;view 的时候，推荐把行号也塞进去（例如&lt;code&gt;1:import os&lt;/code&gt;），这样能有助于编辑（因为 insert 需要指定行号）&lt;/li&gt;
&lt;li&gt;str_replace 的时候应该只有一个精确匹配，匹配不存在或者有多个匹配都是 error&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一些自己的思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对比其他基于 diff 的编辑方式（例如 cline），用行号来声明编辑范围的确会更省 token，但是也对模型能力提出了更高要求（算不对行号的话很容易导致编辑失败）。&lt;/li&gt;
&lt;li&gt;str_replace 只能有一个精确匹配的行为也比较诡异，且参数没有 range，感觉上对于重构似乎不太友好（例如把一个文件里的所有 var1a 换成 slight_better_name）&lt;/li&gt;
&lt;li&gt;只有 create / insert，但没有 update / delete / remove？难道真就只增不减了？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个工具具体是否有用，还是等各路开发者的验证了。毕竟官方只定义了接口，具体实现当然是“留作练习”了。&lt;/p&gt;
&lt;p&gt;src: &lt;a href=&#34;https://docs.anthropic.com/en/docs/build-with-claude/tool-use/text-editor-tool&#34;&gt;https://docs.anthropic.com/en/docs/build-with-claude/tool-use/text-editor-tool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;via: &lt;a href=&#34;https://simonwillison.net/2025/Mar/13/anthropic-api-text-editor-tool/#atom-everything&#34;&gt;https://simonwillison.net/2025/Mar/13/anthropic-api-text-editor-tool/#atom-everything&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>游牧计算</title>
      <link>https://nekonull.me/til/on-nomadic-compute/</link>
      <pubDate>Tue, 11 Mar 2025 14:59:03 +0000</pubDate>
      
      <guid>https://nekonull.me/til/on-nomadic-compute/</guid>
      <description>&lt;p&gt;在使用 LLM 的时候很容易陷入两个极端之一：完全信任服务提供商（无论是 OpenAI/Deepseek 这样的官方服务，还是像 SiliconFlow/OpenRouter 这样的推理提供商），或者是完全自己部署。前者很方便，外包了复杂度，但是也意味着模型不受自己控制；后者很自由，但前提是得有足够多的钱买卡。&lt;/p&gt;
&lt;p&gt;但其实全托管-自托管是一段连续的光谱，游牧计算（Nomadic Compute）则是其中一个有趣的中间点。这个概念似乎一位外国博主 Xe Iaso 创造的，指的是像游牧民族那样，带着自己的数据在不同的云服务基础设施提供商之间漫游，逐水草而居（实际上是价格最低的 GPU）。这样的行为方式之所以能成立，是因为计算（Nvidia GPU）和存储（假设使用某种对象存储服务，例如 S3 或者各种 S3-兼容服务）都是云供应商中立，可以互换的。只要你在需要时在价格最低的云上启动实例，并在不用的时候完全关闭，就能享受到相对低的价格和更自由的选择，并且避免供应商锁定。&lt;/p&gt;
&lt;p&gt;如果这听起来很有趣，你应该继续阅读这篇演讲记录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xeiaso.net/talks/2025/ai-chatbot-friends/&#34;&gt;https://xeiaso.net/talks/2025/ai-chatbot-friends/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者看看已有的帮你自动跨云服务商找最低价 GPU 并完成计算的开源项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/skypilot-org/skypilot/&#34;&gt;https://github.com/skypilot-org/skypilot/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 LLM 计算可视化文字的信息增量</title>
      <link>https://nekonull.me/til/llm-perplexity-visualization/</link>
      <pubDate>Sun, 09 Mar 2025 15:39:03 +0000</pubDate>
      
      <guid>https://nekonull.me/til/llm-perplexity-visualization/</guid>
      <description>&lt;p&gt;读 LLM 推理相关的资料时，想到：在 LLM 前向推理的过程中，会计算从输入开头到当前 token 的所有 token 的 logit，最后采样的时候只用了最后一个 token 的 logit；是否可以构建一个工具，用户输入一段文本，让LLM计算每个token上出现用户输入token的概率，并且加点可视化（概率大：说明这个接续很常见，没什么信息增量；概率小：说明这个接续不太常见，可能有点意思），来得到一个展示文本信息增量的工具？&lt;/p&gt;
&lt;p&gt;搜了搜，发现果然已经有人做过了，用的是 GPT-2 （虽然老了一些，但是足够小，可以直接跑在浏览器里），效果也很棒。或许可以考虑下用现代的 SLM（Small Language Model）更新下？&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://perplexity.vercel.app/&#34;&gt;https://perplexity.vercel.app/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emoji Kitchen - 用 2 个已有的 emoji 生成新的 emoji</title>
      <link>https://nekonull.me/til/emoji-kitchen/</link>
      <pubDate>Sat, 08 Mar 2025 12:41:00 +0000</pubDate>
      
      <guid>https://nekonull.me/til/emoji-kitchen/</guid>
      <description>&lt;p&gt;虽然我是 Gboard 输入法的用户，但是因为日常用 Emoji 不多，直到最近才了解到 Emoji Kitchen 这个功能（或者说项目？）。简而言之，给定两个 Emoji，可以生成一个符合加法语义的新 Emoji （实际上是图像，而不是 Unicode 标准的字符）。例如 热狗+花束=热狗花束。&lt;/p&gt;
&lt;p&gt;阅读相关资料可以发现，每一个组合都是 Google 的设计团队手绘的[1]；虽然有一些组合原则[2]，但是没有自动化（至少从我能找到的信息来看是这样）。考虑到图像生成模型已经广泛可用了，可能未来会有更多的组合是生成而不是手绘的？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;we&amp;rsquo;ve drawn over 30,000 images in just a few years lmao&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://emojikitchen.dev/&#34;&gt;https://emojikitchen.dev/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref1: &lt;a href=&#34;https://jenniferdaniel.substack.com/p/introducing-emoji-kitchen-&#34;&gt;https://jenniferdaniel.substack.com/p/introducing-emoji-kitchen-&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref2: &lt;a href=&#34;https://9to5google.com/2024/12/27/gboard-android-emoji-kitchen-list/&#34;&gt;https://9to5google.com/2024/12/27/gboard-android-emoji-kitchen-list/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 PATH 里的脚本是更好的别名</title>
      <link>https://nekonull.me/til/scripts-in-path-can-do-more-than-alias/</link>
      <pubDate>Thu, 06 Mar 2025 14:10:10 +0000</pubDate>
      
      <guid>https://nekonull.me/til/scripts-in-path-can-do-more-than-alias/</guid>
      <description>&lt;p&gt;我自己的 .bashrc 里有不少小工具，但是要每次改起来得写 shell script 着实烦人（即使能用 LLM 写，也免不了来回调试几次才能满意）。读到这篇文章，我才意识到原来可以写脚本放到 script 里，还有一些额外的优势（不用手动 source 重载、用 shell script 之外的任何语言、各种 shell 都能用）。&lt;/p&gt;
&lt;p&gt;src: &lt;a href=&#34;https://evanhahn.com/why-alias-is-my-last-resort-for-aliases/&#34;&gt;https://evanhahn.com/why-alias-is-my-last-resort-for-aliases/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rust 的日期库的奇妙实现</title>
      <link>https://nekonull.me/til/rust-date-function-math-magic/</link>
      <pubDate>Sun, 02 Mar 2025 13:51:04 +0000</pubDate>
      
      <guid>https://nekonull.me/til/rust-date-function-math-magic/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;问题：实现一个函数，输入 (year, day-of-year) ，输出 (year, month, day)&lt;/li&gt;
&lt;li&gt;基本做法：硬编码一个月份-日期数组，简单写一个循环&lt;/li&gt;
&lt;li&gt;Rust 的新做法：利用一些神奇的数学关系（仿射函数），可以在无循环的情况下实现判断，核心是这两个公式：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let month = (ordinal + 30) * 10 / 306 + 2;
let days_in_preceding_months = (month + 3) * 306 / 10 - 122;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最终优化后的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ordinal_date_to_calendar_date&lt;/span&gt;(year: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, ordinal: &lt;span style=&#34;color:#66d9ef&#34;&gt;u16&lt;/span&gt;) -&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ordinal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ordinal &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; jan_feb_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;59&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; is_leap_year(year) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (month_adj, ordinal_adj) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ordinal &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; jan_feb_len {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, jan_feb_len)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ordinal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ordinal &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; ordinal_adj;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; month &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ordinal &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;268&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8031&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; days_in_preceding_months &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (month &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3917&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3866&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; day &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ordinal &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; days_in_preceding_months;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; month &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; month &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; month_adj;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (year, month &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; _, day &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; _)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;src: &lt;a href=&#34;https://jhpratt.dev/blog/optimizing-with-novel-calendrical-algorithms/&#34;&gt;https://jhpratt.dev/blog/optimizing-with-novel-calendrical-algorithms/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 Unicode 变体选择器隐藏信息</title>
      <link>https://nekonull.me/til/hide-info-unicode-var-selector/</link>
      <pubDate>Sun, 02 Mar 2025 13:46:14 +0000</pubDate>
      
      <guid>https://nekonull.me/til/hide-info-unicode-var-selector/</guid>
      <description>&lt;p&gt;用 variation selector (VS 变体选择器） 把二进制数据藏在 unicode 字符串里；VS 有 256 个（VS1~VS256），刚好一个 byte 一个，二进制数据甚至不需要特殊处理（例如 base64）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般应用（如浏览器）不会渲染出来&lt;/li&gt;
&lt;li&gt;LLM 可以阅读（很适合做 prompt injecting）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;src: &lt;a href=&#34;https://paulbutler.org/2025/smuggling-arbitrary-data-through-an-emoji/&#34;&gt;https://paulbutler.org/2025/smuggling-arbitrary-data-through-an-emoji/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LLMSerp - 把大语言模型当作搜索引擎</title>
      <link>https://nekonull.me/til/llmserp-llm-as-search-engine-page/</link>
      <pubDate>Sun, 02 Mar 2025 09:33:03 +0000</pubDate>
      
      <guid>https://nekonull.me/til/llmserp-llm-as-search-engine-page/</guid>
      <description>&lt;p&gt;LLM 内部已经存储了很多事实性信息。如果通过一些 prompt，让 LLM 输出 [{title, abstract, url}]，就能实现一个搜索引擎。通过把这个&amp;quot;假&amp;quot;搜索引擎和真搜索引擎（例如 Google）的结果混合，Jina.AI 发现可以解决 RAG 中“什么时候需要调用外部搜索”的问题（可以阅读他们的博客文章了解更多信息）。但即使没有这个作用，单纯把 LLM 当作搜索引擎用也是一个很神奇的想法。&lt;/p&gt;
&lt;p&gt;demo: &lt;a href=&#34;https://jina.ai/llm-serp-demo/&#34;&gt;https://jina.ai/llm-serp-demo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;blog: &lt;a href=&#34;https://jina.ai/news/llm-as-serp-search-engine-result-pages-from-large-language-models&#34;&gt;https://jina.ai/news/llm-as-serp-search-engine-result-pages-from-large-language-models&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>debugpy - VSCode 无配置文件调试 Python</title>
      <link>https://nekonull.me/til/debugpy-vscode/</link>
      <pubDate>Sun, 02 Mar 2025 09:01:58 +0000</pubDate>
      
      <guid>https://nekonull.me/til/debugpy-vscode/</guid>
      <description>&lt;p&gt;VSCode 里用 debugpy 可以直接启动 debug session，无需配置文件（launch.json）。基于 &lt;a href=&#34;https://microsoft.github.io/debug-adapter-protocol/&#34;&gt;Debug Adapter Protocol&lt;/a&gt;，和 Language Server Protocl 类似的调试协议。&lt;/p&gt;
&lt;p&gt;src: &lt;a href=&#34;https://github.com/microsoft/vscode-python-debugger/wiki/No%E2%80%90Config-Debugging&#34;&gt;https://github.com/microsoft/vscode-python-debugger/wiki/No%E2%80%90Config-Debugging&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;via: &lt;a href=&#34;https://www.bitecode.dev/p/whats-up-python-better-packaging&#34;&gt;https://www.bitecode.dev/p/whats-up-python-better-packaging&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>要求 LLM 在完成任务时留下笔记</title>
      <link>https://nekonull.me/til/make-llm-take-notes-when-finishing-task/</link>
      <pubDate>Thu, 28 Nov 2024 13:39:17 +0000</pubDate>
      
      <guid>https://nekonull.me/til/make-llm-take-notes-when-finishing-task/</guid>
      <description>&lt;p&gt;ref: &lt;a href=&#34;https://addyosmani.com/blog/automated-decision-logs/&#34;&gt;https://addyosmani.com/blog/automated-decision-logs/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在项目目录下放一个 &lt;code&gt;fyi.md&lt;/code&gt; 或者 &lt;code&gt;notes.md&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 prompt 里要求 LLM 完成任务时同时更新此笔记，包含目标、方案和实际执行的行动&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这看起来是一个显而易见的有效做法，但是之前却没有人提出过！下次使用 cursor 或者其他 LLM 加持的编辑器时我肯定会试试这样做。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>curl 有 LTS 了</title>
      <link>https://nekonull.me/til/curl-has-5-year-lts/</link>
      <pubDate>Sun, 17 Nov 2024 13:27:04 +0000</pubDate>
      
      <guid>https://nekonull.me/til/curl-has-5-year-lts/</guid>
      <description>&lt;p&gt;curl 有 5 年 LTS (Long Time Support) 版本了，不过只有签了商业协议的用户才能使用&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rock-solid.curl.dev/&#34;&gt;https://rock-solid.curl.dev/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;via: &lt;a href=&#34;https://daniel.haxx.se/blog/2024/11/07/rock-solid-curl/&#34;&gt;https://daniel.haxx.se/blog/2024/11/07/rock-solid-curl/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Excel 的自动填充实际上是程序生成</title>
      <link>https://nekonull.me/til/excel-auto-complete-as-program-systhenis/</link>
      <pubDate>Sun, 17 Nov 2024 13:36:00 +0800</pubDate>
      
      <guid>https://nekonull.me/til/excel-auto-complete-as-program-systhenis/</guid>
      <description>&lt;p&gt;原来 Excel 里自动填充是有论文的，底层是实现了程序生成；另外据说 Google Sheets 的自动填充之所以没有微软的好，是因为微软申请了专利，Google 绕不过去。&lt;/p&gt;
&lt;p&gt;Automating String Processing in Spreadsheets Using Input-Output Examples
&lt;a href=&#34;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/popl11-synthesis.pdf&#34;&gt;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/popl11-synthesis.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;via
&lt;a href=&#34;https://danluu.com/ballmer/&#34;&gt;https://danluu.com/ballmer/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
